#!/usr/bin/env python3 -B
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this file,
# You can obtain one at http://mozilla.org/MPL/2.0/.

import argparse
import logging
import pathlib
import re
import sys

import lxml.etree
import lxml.html

class NewSyntaxConfig:
    useRawName = True
    useProperty = True
    useDescriptorSyntax = True
    useInstanceSyntax = True
    usePrototypeInterface = True
    useValueSyntax = True
    useAtAtSymbol = True
    useInheritanceExpression = True


class CompatibleConfig:
    useRawName = False
    useProperty = False
    useDescriptorSyntax = False
    useInstanceSyntax = False
    usePrototypeInterface = False
    useValueSyntax = False
    useAtAtSymbol = False
    useInheritanceExpression = False


config = NewSyntaxConfig


# Default values of attributes of properties.
#
# Defined in "ECMAScript Standard Built-in Objects" section, and verified
# while parsing the section.
DEFAULT_WRITABLE = True
DEFAULT_ENUMERABLE = False
DEFAULT_CONFIGURABLE = True

fileHeader = """\
/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */

/* This file is generated by es2idl.py */
"""


def removeIntrinsicSign(text):
    return text.replace("%", "")


def toSymbolPropName(name):
    assert name.startswith("Symbol.")

    if config.useAtAtSymbol:
        return "@@{}".format(name[7:])
    return name


def toPropName(name):
    if name.startswith("Symbol."):
        return toSymbolPropName(name)

    return name


def toSymbolPropExpr(parent, name):
    assert name.startswith("Symbol.")

    return "{}[@@{}]".format(parent, name[7:])


def toPropExpr(parent, name):
    if name.startswith("Symbol."):
        return toSymbolPropExpr(parent, name)
    return "{}.{}".format(parent, name)


def toRelativeName(reference, owner):
    name = reference.prop.name

    if reference.parent == owner:
        return toPropName(name)

    if reference.prop.owner.qualifiedName is None:
        return toPropExpr(reference.prop.owner.name, name)

    return toPropExpr(reference.prop.owner.qualifiedName, name)



class IDLError(Exception):
    """Error annotated with the TreeWalker's context."""

    def __init__(self, message):
        messages = [message]

        if TreeWalker.path:
            source = TreeWalker.path

            if TreeWalker.currentNode is not None:
                source += ":{}".format(TreeWalker.currentNode.sourceline)

            messages.append("at {}".format(source))

        if TreeWalker.title is not None:
            messages.append("for {}".format(TreeWalker.title))

        if TreeWalker.specURL is not None:
            messages.append("for {}".format(TreeWalker.specURL))

        text = TreeWalker.maybeCurrentParsingText()
        if text is not None:
            messages.append('while parsing "{}"'.format(text))

        context = TreeWalker.maybeCurrentOperandContext()
        if context is not None:
            messages.append("in {}".format(context))

        super().__init__("\n  ".join(messages))


class Index:
    """An ordered map from possible interface name to interface value."""

    values = {}

    @classmethod
    def set(cls, name, value):
        if name in cls.values:
            if cls.values[name] != value:
                raise IDLError(
                    "Indexed value mismatch for {}. expected {}, got {}".format(
                        name, cls.values[name], value
                    )
                )
            return

        if name == "GeneratorFunction.prototype.prototype":
            return
        if name == "AsyncGeneratorFunction.prototype.prototype":
            return

        cls.values[name] = value


class NamedObjects:
    """A map from the name of top-level objects to the value."""

    values = {}

    @classmethod
    def add(cls, value):
        cls.addWith(value, value.name)
        pass

    @classmethod
    def addWith(cls, value, expr):
        assert "%" not in expr

        if "." in expr:
            # Defining a property.
            components = expr.split(".")
            parentExpr = ".".join(components[:-1])
            name = components[-1]
            parent = evaluateExpression(parentExpr)

            if not parent.hasProperty(name):
                raise IDLError("{} must have the {} property".format(parentExpr, name))

            logger.debug("Setting the {} property for {}".format(name, parentExpr))
            parent.getProperty(name).value = value

            if not value.name.endswith(" Prototype"):
                Index.set(expr, value)

            return

        # Defining a top-level object.

        logger.debug("Register named object: {}".format(expr))

        if expr in cls.values:
            if cls.values[expr] != value:
                raise IDLError("{} must be unique".format(expr))

        cls.values[expr] = value
        Index.set(expr, value)

    @classmethod
    def has(cls, name):
        return name in cls.values

    @classmethod
    def get(cls, name):
        return cls.values[name]


class RefTarget:
    """Target of href, and a map from RefTarget instance to value."""

    values = {}

    def __init__(self, specURL, ref, header):
        self.specURL = specURL
        self.ref = ref
        self.header = header

    def toURI(self):
        return "{}#{}".format(self.specURL, self.ref)

    @classmethod
    def add(cls, refTarget, value):
        uri = refTarget.toURI()
        if uri not in cls.values:
            cls.values[uri] = set()

        cls.values[uri].add(value)

    @classmethod
    def has(cls, refTarget):
        uri = refTarget.toURI()
        return uri in cls.values

    @classmethod
    def get(cls, refTarget):
        uri = refTarget.toURI()
        return cls.values[uri]


class Value:
    """Base class for values"""

    def __init__(self, value, refTarget):
        self.value = value
        self.refTarget = None

        self.parent = None

        self.referrers = []

        if refTarget:
            self.setRefTarget(refTarget)

    def setParent(self, parent, propName):
        if not isinstance(parent, Object):
            raise IDLError("Parent must be Object : {}".format(parent))

        if self.parent is not None:
            return

        self.parent = parent

    def setRefTarget(self, refTarget):
        self.refTarget = refTarget
        RefTarget.add(refTarget, self)

    def shallowClone(self):
        return Value(self.value, self.refTarget)

    def extendedAttributeName(self):
        return "Value"

    def valueExpression(self):
        return str(self.value)

    def extendedValueExpression(self):
        return self.valueExpression()

    def extendedAttributes(self):
        if config.useValueSyntax:
            return []

        if self.value is None:
            return []

        return ['{}="{}"'.format(self.extendedAttributeName(),
                                 self.extendedValueExpression())]

    def initializer(self, isConst):
        if self.value is None:
            return ""

        if config.useValueSyntax or isConst:
            return " = {}".format(self.valueExpression())
        return ""

    def equals(self, other):
        return self == other


class NumberValue(Value):
    """Value with actual number."""

    def __init__(self, value, refTarget):
        super().__init__(value, refTarget)

        if value in ["-Infinity", "Infinity", "NaN"]:
            pass
        elif re.match(r"-?[0-9]+$", str(value)):
            pass
        else:
            raise IDLError("NumberValue must match number syntax : {}".format(value))

    def shallowClone(self):
        return NumberValue(self.value, self.refTarget)

    def extendedAttributeName(self):
        return "NumberValue"

    def equals(self, other):
        if not isinstance(other, NumberValue):
            return False
        return self.value == other.value


class SpecialNumberValue(Value):
    """Pre-defined numeric value."""

    supported = [
        "EPSILON",
        "MAX_VALUE",
        "MIN_VALUE",
        "E",
        "LN10",
        "LN2",
        "LOG10E",
        "LOG2E",
        "PI",
        "SQRT1_2",
        "SQRT2",
    ]

    def __init__(self, value, refTarget):
        super().__init__(value, refTarget)

        if value not in SpecialNumberValue.supported:
            raise IDLError("Unsupported value : {}".format(value))

    def shallowClone(self):
        return SpecialNumberValue(self.value, self.refTarget)

    def extendedAttributeName(self):
        return "NumberValue"

    def equals(self, other):
        if not isinstance(other, SpecialNumberValue):
            return False
        return self.value == other.value


class StringValue(Value):
    def __init__(self, value, refTarget):
        super().__init__(value, refTarget)

    def shallowClone(self):
        return StringValue(self.value, self.refTarget)

    def extendedAttributeName(self):
        return "StringValue"

    def valueExpression(self):
        return '"{}"'.format(self.value)

    def extendedValueExpression(self):
        return '{}'.format(self.value)

    def equals(self, other):
        if not isinstance(other, StringValue):
            return False
        return self.value == other.value


class SymbolValue(Value):
    def __init__(self, value, refTarget):
        super().__init__(value, refTarget)

    def shallowClone(self):
        return SymbolValue(self.value, self.refTarget)

    def extendedAttributeName(self):
        return "SymbolValue"

    def valueExpression(self):
        return toSymbolPropName(self.value)

    def equals(self, other):
        if not isinstance(other, SymbolValue):
            return False
        return self.value == other.value


class NullValue(Value):
    def __init__(self, refTarget):
        super().__init__("null", refTarget)

    def shallowClone(self):
        return NullValue(self.refTarget)

    def equals(self, other):
        if not isinstance(other, NullValue):
            return False
        return True


class UndefinedValue(Value):
    def __init__(self, refTarget):
        super().__init__("undefined", refTarget)

    def shallowClone(self):
        return UndefinedValue(self.refTarget)

    def equals(self, other):
        if not isinstance(other, UndefinedValue):
            return False
        return True


class GlobalThisValue(Value):
    """The value of globalThis."""

    def __init__(self, refTarget):
        super().__init__("GlobalThisValue", refTarget)

    def shallowClone(self):
        return GlobalThisValue(self.refTarget)


class UnscopablesValue(Value):
    """The value of [Symbol.unscopables]."""

    def __init__(self, names, refTarget):
        super().__init__(None, refTarget)

        self.names = names


class ConstructorNameValue(Value):
    """The name of the constructor.

    Used by template."""

    def __init__(self, refTarget):
        super().__init__(None, refTarget)


class ElementSizeValue(Value):
    """The byte size of TypedArray's element.

    Used by template."""

    def __init__(self, refTarget):
        super().__init__(None, refTarget)


reservedNames = [
    "or",
    "any",
    "constructor",
    "prototype",
    "Infinity",
    "NaN",
    "undefined",
    "Promise",
    "ArrayBuffer",
    "ArrayBufferView",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "includes",
    "toJSON",
    "toString",
]


def escapeName(name):
    """Convert a function or property name into a name usable in WebIDL."""

    if config.useRawName:
        return name

    if name in reservedNames:
        return "_" + name

    m = re.match(r"__(.+)__$", name)
    if m:
        return "_" + m.group(1)

    m = re.match(r"Symbol\.(.+)$", name)
    if m:
        return "_symbol_" + m.group(1)

    return name


class Object(Value):
    """An instance object, or base class of prototypes and functions"""

    def __init__(self, name, refTarget):
        assert "%" not in name

        super().__init__(None, refTarget)

        if not re.match(r"Symbol\.[A-Za-z0-9]+", name):
            if "." in name or "[" in name:
                raise IDLError(
                    "Object name shouldn't contian property operation : {}".format(name)
                )

        self.name = name
        self.safeName = escapeName(name)

        self.qualifiedName = None
        self.prototypeSlot = None

        self.props = {}

        self.mod = None

    def copySlotsFrom(self, other):
        self.setPrototypeSlot(other.prototypeSlot)

    def hasSafeName(self):
        """Returns true if this object has different name for WebIDL than
        the actual name"""

        return self.safeName != self.name

    def hasProperty(self, name):
        return name in self.props

    def getProperty(self, name):
        if not self.hasProperty(name):
            raise IDLError('Property "{}" should exist in {}'.format(name, self.name))
        return self.props[name]

    def setProperty(self, name, prop):
        if self.hasProperty(name):
            raise IDLError(
                'Property "{}" conflicts in {}'.format(name, self.name)
            )

        self.props[name] = prop

    def setPrototypeSlot(self, prototypeSlot):
        if self.prototypeSlot is not None:
            if self.prototypeSlot != prototypeSlot:
                raise IDLError(
                    "[[Prototype]] slot cannot be overwritten : {} vs {}".format(
                        self.prototypeSlot, prototypeSlot
                    )
                )

        self.prototypeSlot = prototypeSlot

    def setParent(self, parent, propName):
        if not isinstance(parent, Object):
            raise IDLError("Parent must be Object : {}".format(parent))

        if self.parent is not None:
            return

        found = False
        n = parent
        while n is not None:
            if n == self:
                found = True
            n = n.parent
        if found:
            # Circular reference
            return

        self.parent = parent

        if self.qualifiedName is not None:
            return

        if propName.startswith("Symbol."):
            propExpr = "[{}]".format(propName)
        else:
            propExpr = ".{}".format(propName)

        if parent.qualifiedName is not None:
            parentExpr = parent.qualifiedName
        else:
            parentExpr = parent.name

        self.qualifiedName = parentExpr + propExpr

    def shallowClone(self):
        raise IDLError("Object cannot be cloned: {} : {}".format(self.name, str(self)))


class SingletonObject(Object):
    """A singleton object"""

    def __init__(self, name, refTarget):
        super().__init__(name, refTarget)


class InstanceObject(Object):
    """An instance object"""

    def __init__(self, name, refTarget):
        super().__init__(name, refTarget)


class ExoticObject(Object):
    """An exotic object"""

    def __init__(self, name, refTarget):
        super().__init__(name, refTarget)


class Prototype(Object):
    """A prototype object."""

    values = {}

    def __init__(self, name, refTarget):
        super().__init__(name, refTarget)

        Prototype.set(name, self)

        self.instance = None
        self.isCustom = False

    @classmethod
    def set(cls, name, value):
        if name in cls.values:
            raise IDLError("Prototype name should be unique : {}".format(name))

        logger.debug("Register prototype: {}".format(name))

        cls.values[name] = value

    def setInstance(self, instance):
        if self.instance is not None:
            raise IDLError("Instance cannot be overwitten")

        self.instance = instance

    def hasInstance(self):
        return self.instance is not None

    def getInstance(self):
        return self.instance


class Dictionary(Object):
    def __init__(self, name, refTarget):
        super().__init__(name, refTarget)


class Function(Object):
    def __init__(self, name, refTarget):
        super().__init__(name, refTarget)

        self.params = None
        self.explicitLength = None
        self.explicitName = None

    def copySlotsFrom(self, other):
        super().copySlotsFrom(other)

        self.setParams(other.params)
        self.setExplicitLength(other.explicitLength)
        self.setExplicitName(other.explicitName)

    def setParams(self, params):
        if self.params:
            if str(self.params) != str(params):
                raise IDLError(
                    "Parameter should match: {} vs {}".format(
                        str(self.params), str(params)
                    )
                )
            return

        self.params = params

    def setExplicitLength(self, explicitLength):
        if self.explicitLength is not None:
            raise IDLError('Explicit "length" cannot be overwitten')

        self.explicitLength = explicitLength

    def setExplicitName(self, explicitName):
        if self.explicitName is not None:
            raise IDLError('Explicit "name" cannot be overwitten')

        self.explicitName = explicitName

    def extendedAttributes(self):
        extendedAttributes = super().extendedAttributes()

        if self.explicitLength:
            extendedAttributes.append('Length="{}"'.format(self.explicitLength))

        return extendedAttributes


class Callback(Function):
    def __init__(self, name, typeName, refTarget):
        super().__init__(name, refTarget)

        self.typeName = typeName


class Constructor(Function):
    def __init__(self, name, refTarget):
        super().__init__(name, refTarget)

        self.instance = None
        self.objectsRefTarget = None
        self.constructorMod = None

        logger.debug('Create "{}" constructor'.format(self.name))

    def setObjectsRefTarget(self, objectsRefTarget):
        self.objectsRefTarget = objectsRefTarget
        RefTarget.add(objectsRefTarget, self)

    def ensurePrototype(self, refTarget):
        if not self.hasPrototype():
            raise IDLError("Prototype should be defined")

        prop = self.props["prototype"]

        if isinstance(prop.value, ReferenceValue):
            protoName = self.name + " Prototype"
            protoValue = Prototype(protoName, refTarget)
            prop.setValue(protoValue)
        else:
            protoValue = prop.value

        if not isinstance(protoValue, Prototype):
            raise IDLError(
                "The prototype property must be a Prototype : {}".format(prop.value)
            )

        return protoValue

    def hasPrototype(self):
        return self.hasProperty("prototype")

    def getPrototype(self):
        return self.getProperty("prototype").getValue()


class ObjectRefValue(Value):
    """A reference for object, used while printing an interface."""

    def __init__(self, value, refTarget):
        super().__init__(value, refTarget)

    def shallowClone(self):
        return ObjectRefValue(self.value, self.refTarget)

    def extendedAttributeName(self):
        return "ObjectValue"


class ReferenceValue:
    """A base class of references to another value."""

    values = []

    def __init__(self):
        self.parent = None
        self.prop = None

        self.derefValue = None

        ReferenceValue.values.append(self)

    def setParent(self, parent, propName):
        if not isinstance(parent, Object):
            raise IDLError("Parent must be Object : {}".format(parent))

        if self.parent is None:
            self.parent = parent

    @classmethod
    def derefAll(cls):
        logger.debug("Dereference all references")

        for value in cls.values:
            value.deref()


class URIReferenceValue(ReferenceValue):
    """A reference to an object defined in given URI."""

    def __init__(self, refTarget):
        super().__init__()

        self.refTarget = refTarget

    def deref(self):
        if self.derefValue is not None:
            return self.derefValue

        if not RefTarget.has(self.refTarget):
            raise IDLError(
                "Target value must be known: {}".format(self.refTarget.toURI())
            )

        values = RefTarget.get(self.refTarget)

        if len(values) > 1:
            raise IDLError(
                "Target value must be unique: {}".format(self.refTarget.toURI())
            )

        value = list(values)[0]

        value.referrers.append(self)

        self.derefValue = value
        return value

    def __str__(self):
        return "URIReferenceValue({})".format(self.refTarget.toURI())


class PrototypeReferenceValue(ReferenceValue):
    """A reference to a prototype object with given name"""

    def __init__(self, expr):
        super().__init__()

        self.expr = expr

    def deref(self):
        if self.derefValue is not None:
            return self.derefValue

        protoName = self.expr + " Prototype"

        if protoName not in Prototype.values:
            raise IDLError("Prototype name should be known : {}".format(protoName))

        value = Prototype.values[protoName]
        value.referrers.append(self)

        self.derefValue = value
        return value

    def __str__(self):
        return "PrototypeReference({})".format(self.expr)


class ExpressionReferenceValue(ReferenceValue):
    """A reference to an expression"""

    def __init__(self, expr):
        super().__init__()

        assert "%" not in expr

        self.expr = expr

    def deref(self):
        if self.derefValue is not None:
            return self.derefValue

        value = evaluateExpression(self.expr)
        value.referrers.append(self)

        self.derefValue = value
        return value

    def __str__(self):
        return "ExpressionReference({})".format(self.expr)


class Parameter:
    """A parameter of a function."""

    def __init__(self, name, optional, variadic):
        self.name = name
        self.optional = optional
        self.variadic = variadic

    def __str__(self):
        if self.optional:
            return "optional any " + self.name

        if self.variadic:
            return "any... " + self.name

        return "any " + self.name

    def isRequired(self):
        return not self.optional and not self.variadic


class ParameterList:
    """A list of parameters of a function."""

    def __init__(self, paramsText):
        input = paramsText.strip()

        self.params = []

        optional = False
        variadic = False

        while input != "":
            m = re.match(r",(.*)$", input)
            if m:
                input = m.group(1).strip()
                continue

            m = re.match(r"\[(.*)$", input)
            if m:
                optional = True
                input = m.group(1).strip()
                continue

            m = re.match(r"\](.*)$", input)
            if m:
                input = m.group(1).strip()
                continue

            m = re.match(r"\.\.\.(.*)$", input)
            if m:
                variadic = True
                input = m.group(1).strip()
                continue

            m = re.match(r"_([A-Za-z][A-Za-z0-9]*)_(.*)$", input)
            if m:
                name = m.group(1)
                input = m.group(2).strip()

                self.params.append(Parameter(name, optional, variadic))
                optional = False
                variadic = False
                continue

            raise IDLError("Cannot parse " + paramsText)

    def __str__(self):
        isFirst = True
        hadNonRequired = False
        params = ""

        for param in self.params:
            if not param.isRequired():
                hadNonRequired = True

            if param.isRequired() and hadNonRequired:
                params += " /* "

            if not isFirst:
                params += ", "

            params += str(param)

            if param.isRequired() and hadNonRequired:
                params += " */"

            isFirst = False

        return "({})".format(params)


class Attributes:
    """Attributes of a property."""

    def __init__(self):
        self.writable = DEFAULT_WRITABLE
        self.enumerable = DEFAULT_ENUMERABLE
        self.configurable = DEFAULT_CONFIGURABLE

    def toTuple(self):
        return (self.writable,
                self.enumerable,
                self.configurable)

    def fromText(attrsText):
        input = attrsText.strip()

        attrs = Attributes()

        while input != "":
            m = re.match(r",(.*)$", input)
            if m:
                input = m.group(1).strip()
                continue

            m = re.match(r"{(.*)$", input)
            if m:
                input = m.group(1).strip()
                continue

            m = re.match(r"}(.*)$", input)
            if m:
                input = m.group(1).strip()
                continue

            m = re.match(r" (.*)$", input)
            if m:
                input = m.group(1).strip()
                continue

            m = re.match("\\[\\[Writable\\]\\]: \\*?(true|false)\\*?(.*)", input)
            if m:
                attrs.writable = m.group(1) == "true"
                input = m.group(2).strip()
                continue

            m = re.match("\\[\\[Enumerable\\]\\]: \\*?(true|false)\\*?(.*)", input)
            if m:
                attrs.enumerable = m.group(1) == "true"
                input = m.group(2).strip()
                continue

            m = re.match("\\[\\[Configurable\\]\\]: \\*?(true|false)\\*?(.*)", input)
            if m:
                attrs.configurable = m.group(1) == "true"
                input = m.group(2).strip()
                continue

            raise IDLError("Cannot parse " + attrsText)

        return attrs


class DefaultAttributes(Attributes):
    """Special value to distinguish the default attributes."""

    pass


def populateDescriptor(kind, attrs,
                       defaultWritable,
                       defaultEnumerable,
                       defaultConfigurable,
                       specifiers, extendedAttributes):
    if kind != "attribute" and attrs.writable != defaultWritable:
        if attrs.writable:
            if config.useDescriptorSyntax:
                specifiers.append("writable")
            else:
                extendedAttributes.append("Writable")
        else:
            if config.useDescriptorSyntax:
                specifiers.append("readonly")
            else:
                extendedAttributes.append("ReadOnly")

    if attrs.enumerable != defaultEnumerable:
        if attrs.enumerable:
            if config.useDescriptorSyntax:
                specifiers.append("enumerable")
            else:
                extendedAttributes.append("Enumerable")
        else:
            if config.useDescriptorSyntax:
                specifiers.append("non_enumerable")
            else:
                extendedAttributes.append("NonEnumerable")

    if attrs.configurable != defaultConfigurable:
        if attrs.configurable:
            if config.useDescriptorSyntax:
                specifiers.append("configurable")
            else:
                extendedAttributes.append("Configurable")
        else:
            if config.useDescriptorSyntax:
                specifiers.append("non_configurable")
            else:
                extendedAttributes.append("NonConfigurable")


class Property:
    def __init__(self, owner, name, value, refTarget):
        assert "%" not in name

        self.owner = owner
        self.name = name
        self.safeName = escapeName(name)
        self.value = None
        self.refTarget = refTarget

        self.hasGetter = False
        self.hasSetter = False

        self.isReference = False

        self.isConst = False

        self.attrs = DefaultAttributes()

        if value:
            self.setValue(value)

        self.mod = None

        self.cachedExtendedAttributes = None
        self.cachedString = None

    def hasSafeName(self):
        """Returns true if this object has different name for WebIDL than
        the actual name"""

        return self.safeName != self.name

    def isDataProperty(self):
        return not self.isAccessor()

    def isAccessor(self):
        return self.hasGetter or self.hasSetter

    def setValue(self, value):
        if isinstance(self.value, Function):
            if isinstance(value, ReferenceValue):
                # Function to initial value with reference.
                pass
            else:
                raise IDLError(
                    'Function property "{}" can be overwitten only by reference : {}'.format(
                        self.name, value
                    )
                )
        elif isinstance(self.value, ReferenceValue):
            if isinstance(value, Object):
                # Resolved initial value.
                pass
            elif isinstance(value, TemplateInstantiation):
                # Resolved initial value.
                pass
            elif isinstance(value, ReferenceValue):
                # Temporal's properties.
                pass
            else:
                raise IDLError(
                    'Reference property "{}" cannot be overwitten with : {}'.format(
                        self.name, value
                    )
                )
        elif self.value is not None:
            raise IDLError(
                'Property "{}" value cannot be overwritten : {} vs {}'.format(
                    self.name, self.value, value
                )
            )

        if not isinstance(value, TemplateInstantiation):
            value.setParent(self.owner, self.name)
        self.value = value
        if isinstance(value, ReferenceValue):
            self.isReference = True
            value.prop = self

    def getValue(self):
        if isinstance(self.value, ReferenceValue):
            logger.debug("Dereference property value: {}".format(self.name))
            self.value = self.value.deref()

        return self.value

    def setAttributes(self, attrs):
        if not isinstance(self.attrs, DefaultAttributes):
            raise IDLError("Current attribute must be default")

        self.attrs = attrs

    def getSpecURL(self):
        if self.value:
            return self.value.refTarget.specURL

        return self.refTarget.specURL

    def isPrototypeProperty(self):
        return isinstance(self.owner, Prototype)

    def cloneWithValue(self, value):
        if self.isAccessor():
            raise IDLError('Accessor "{}" cannot be cloned'.format(self.name))

        newProp = Property(self.owner, self.name, value, self.refTarget)
        newProp.attrs = self.attrs
        newProp.isReference = False
        newProp.mod = self.mod
        return newProp

    def calculateExtendedAttributesAndString(self):
        extendedAttributes = []
        specifiers = []

        name = self.name
        if not config.useRawName and self.hasSafeName():
            extendedAttributes.append('Name="{}"'.format(name))
            name = self.safeName
        elif name.startswith("_"):
            name = "_" + name
        else:
            if name.startswith("Symbol."):
                name = toSymbolPropName(name)

        unforgeable = False

        if self.isDataProperty():
            value = self.getValue()

            if self.isConst:
                defaultWritable = False
                defaultEnumerable = True
                defaultConfigurable = False

                kind = "const"
            elif isinstance(value, Function):
                # https://webidl.spec.whatwg.org/#define-the-operations
                #
                # 3. Let modifiable be false if op is unforgeable
                #    and true otherwise.
                # 4. Let desc be the
                #    PropertyDescriptor{[[Value]]: method,
                #                       [[Writable]]: modifiable,
                #                       [[Enumerable]]: true,
                #                       [[Configurable]]: modifiable}.

                modifiable = not unforgeable

                defaultWritable = modifiable
                defaultEnumerable = True
                defaultConfigurable = modifiable

                kind = "method"
            else:
                # Not representable with the default WebIDL.

                if config.useProperty:
                    kind = "property"

                    defaultWritable = DEFAULT_WRITABLE
                    defaultEnumerable = DEFAULT_ENUMERABLE
                    defaultConfigurable = DEFAULT_CONFIGURABLE
                else:
                    extendedAttributes.append("DataProperty")
                    kind = "attribute"

                    defaultWritable = None
                    defaultEnumerable = None
                    defaultConfigurable = None
        else:
            # https://webidl.spec.whatwg.org/#define-the-attributes
            # 4. Let configurable be false if attr is unforgeable
            #    and true otherwise.
            # 5. Let desc be the
            #    PropertyDescriptor{[[Get]]: getter,
            #                       [[Set]]: setter,
            #                       [[Enumerable]]: true,
            #                       [[Configurable]]: configurable}.

            kind = "attribute"

            defaultWritable = None
            defaultEnumerable = True
            defaultConfigurable = not unforgeable

        populateDescriptor(kind, self.attrs,
                           defaultWritable,
                           defaultEnumerable,
                           defaultConfigurable,
                           specifiers, extendedAttributes)

        self.cachedExtendedAttributes = extendedAttributes

        typeStr = "any"
        suffix = ""

        if self.isAccessor():
            if not self.hasSetter:
                specifiers.append("readonly")

            specifiers.append(kind)
        else:

            value = self.getValue()

            if kind == "method":
                suffix = str(value.params)
            else:
                specifiers.append(kind)

                suffix = value.initializer(self.isConst)

        self.cachedString = " ".join(specifiers + [typeStr, name + suffix])


    def extendedAttributes(self):
        self.calculateExtendedAttributesAndString()

        extendedAttributes = self.cachedExtendedAttributes

        value = self.getValue()

        if self.isConst:
            return extendedAttributes

        if self.isDataProperty():
            return extendedAttributes + value.extendedAttributes()

        return extendedAttributes

    def __str__(self):
        self.calculateExtendedAttributesAndString()

        return self.cachedString


class DictionaryMember(Property):
    def __init__(self, owner, name, value, refTarget):
        super().__init__(owner, name, value, refTarget)

        self.optional = False


class TemplateInstantiation:
    """An instantiation of given template, such as _NativeError_."""

    values = []

    def __init__(self, templateName, name, refTarget):
        self.templateName = templateName
        self.name = name
        self.refTarget = refTarget
        RefTarget.add(refTarget, self)

        self.referrers = []

        # Parameter for the template, e.g. ElementSize for _TypedArray_.
        self.templateParams = None

        # The definition of the template constructor.
        self.origCtor = None

        # The instantiated constructor.
        self.ctor = None

        self.parent = None
        self.qualifiedName = name

        TemplateInstantiation.values.append(self)

    def setTemplateParams(self, templateParams):
        if self.templateParams is not None:
            raise IDLError("Template parameters cannot be overwritten")

        self.templateParams = templateParams

    @classmethod
    def instantiateAll(cls):
        logger.debug("Instantiate templates")

        for value in cls.values:
            value.instantiate()

    def instantiate(self):
        if self.ctor:
            return self.ctor

        self.origCtor = NamedObjects.get(self.templateName)
        self.instantiateOne(self.origCtor)
        return self.ctor

    def instantiateOne(self, origValue):
        if isinstance(origValue, ConstructorNameValue):
            return StringValue(self.name, origValue.refTarget)

        if isinstance(origValue, ElementSizeValue):
            return NumberValue(self.templateParams["ElementSize"], origValue.refTarget)

        if not isinstance(origValue, Object):
            return origValue.shallowClone()

        if isinstance(origValue, Constructor):
            if origValue != self.origCtor:
                return origValue

            if self.ctor:
                return self.ctor

            value = Constructor(self.name, self.refTarget)
            value.copySlotsFrom(origValue)
            value.setObjectsRefTarget(self.refTarget)
            value.referrers = self.referrers
            value.qualifiedName = self.name

            self.ctor = value
        elif isinstance(origValue, Prototype):
            value = Prototype(self.name + " Prototype", None)
            value.copySlotsFrom(origValue)
        elif isinstance(origValue, Function):
            value = origValue
        else:
            raise IDLError(
                "Template shouldn't contain plain object : {}".format(origValue)
            )

        for propName, prop in origValue.props.items():
            if prop.isAccessor():
                raise IDLError("Template shouldn't contain accessor: {}".format(prop))

            propValue = self.instantiateOne(prop.getValue())
            newProp = Property(value, propName, propValue, prop.refTarget)
            newProp.setAttributes(prop.attrs)
            value.setProperty(propName, newProp)

        return value


def evaluateExpression(expr, allowUndefined=False):
    """Evaluate given expression and returns value.

    If allowUndefined is not specified or is False, the result of the expression
    must be defined.

    If allowUndefined is True and if the result of the expression is not
    defined, returns None."""

    assert "%" not in expr

    if "[" in expr:
        raise IDLError("Expression must not contain []: {}".format(expr))
    if " " in expr:
        raise IDLError("Expression must not contain space: {}".format(expr))

    names = expr.split(".")
    source = NamedObjects

    topLevelName = names[0]

    if not source.has(topLevelName):
        if allowUndefined:
            return None
        raise IDLError(
            "Top-level name should exist : {} for {}".format(topLevelName, expr)
        )

    value = source.get(topLevelName)

    if value is None:
        if allowUndefined:
            return None
        raise IDLError(
            "Top-level value must be defined : {} for {}".format(topLevelName, expr)
        )

    if isinstance(value, TemplateInstantiation):
        value = value.instantiate()

    for propName in names[1:]:
        if not value.hasProperty(propName):
            if allowUndefined:
                return None
            raise IDLError("Property should exist : {} in {}".format(propName, expr))

        value = value.getProperty(propName).getValue()
        if value is None:
            if allowUndefined:
                return None
            raise IDLError(
                "Property value should be defined : {} in {}".format(propName, expr)
            )

    return value


class Context:
    """A context of TreeWalker's context stack."""

    def __init__(self):
        pass


class RefTargetContext(Context):
    """The current section's RefTarget."""

    def __init__(self, refTarget):
        self.refTarget = refTarget


class ParsingTextContext(Context):
    """The currently parsing text."""

    def __init__(self, text):
        self.text = text


class OperandContext(Context):
    """A base class for the operand of the current definition."""

    def __init__(self):
        super().__init__()


class TypedArrayContext(OperandContext):
    """The "TypedArray Objects" section."""

    def __init__(self, refTarget, header):
        super().__init__()

        self.refTarget = refTarget
        self.ctor = None
        self.ctorTemplate = None
        self.header = header

    def __str__(self):
        ctorName = None
        if self.ctor:
            ctorName = self.ctor.name

        ctorTemplateName = None
        if self.ctorTemplate:
            ctorTemplateName = self.ctorTemplate.name

        return "{}({}, {}) # {}".format(
            self.__class__.__name__, ctorName, ctorTemplateName,
            self.header
        )


class NativeErrorContext(OperandContext):
    """The "Native Error Types Used in This Standard" section."""

    def __init__(self, header):
        super().__init__()

        self.header = header

    def __str__(self):
        return "{} # {}".format(
            self.__class__.__name__, self.header
        )


class NativeErrorTemplateInstantiationContext(OperandContext):
    """Each instantiation of _NativeError_."""

    def __init__(self, ctor, header):
        super().__init__()

        self.ctor = ctor
        self.header = header

    def __str__(self):
        return "{}({}) # {}".format(
            self.__class__.__name__, self.ctor.name, self.header
        )


class SingletonObjectContext(OperandContext):
    """Singleton object's section."""

    def __init__(self, value, header):
        super().__init__()

        self.singleton = value
        self.header = header

    def __str__(self):
        return "{}({}) # {}".format(
            self.__class__.__name__, self.singleton.name, self.header
        )


class MultipleObjectContext(OperandContext):
    """Instantiateable object's section."""

    def __init__(self, name, entireExpr, header, objectsRefTarget):
        super().__init__()

        self.name = name
        self.qualifiedName = entireExpr
        self.header = header
        self.objectsRefTarget = objectsRefTarget

        self.ctor = None
        self.proto = None

    def __str__(self):
        return "{}({}) # {}".format(
            self.__class__.__name__, self.name, self.header
        )


class PrototypeObjectContext(OperandContext):
    """Prototype object's section."""

    def __init__(self, proto, header):
        super().__init__()

        self.proto = proto
        self.header = header

    def __str__(self):
        return "{}({}) # {}".format(
            self.__class__.__name__, self.proto.name, self.header
        )


class ConstructorListContext(OperandContext):
    """The "... Constructors" section."""

    def __init__(self, ctor, header):
        super().__init__()

        self.ctor = ctor
        self.header = header

    def __str__(self):
        return "{}({}) # {}".format(
            self.__class__.__name__, self.ctor.name, self.header
        )


class ConstructorContext(OperandContext):
    """Constructor function's section."""

    def __init__(self, ctor, header):
        super().__init__()

        self.ctor = ctor
        self.header = header

    def __str__(self):
        return "{}({}) # {}".format(
            self.__class__.__name__, self.ctor.name, self.header
        )


class PropertyListContext(OperandContext):
    """The "Properties of ..." section."""

    def __init__(self, obj, header, refTarget):
        super().__init__()

        self.obj = obj
        self.header = header
        self.refTarget = refTarget

    def __str__(self):
        return "{}({}) # {}".format(
            self.__class__.__name__, self.obj.name, self.header
        )


class PropertyContext(OperandContext):
    """Each property of singleton/prototype/constructor."""

    def __init__(self, owner, prop, header):
        super().__init__()

        self.owner = owner
        self.prop = prop
        self.header = header

    def __str__(self):
        return '{}({}, "{}") # {}'.format(
            self.__class__.__name__, self.owner.name, self.prop.name,
            self.header
        )


class InstancePropertyContext(PropertyContext):
    """Each property of an instance object."""

    def __init__(self, owner, prop, header):
        super().__init__(owner, prop, header)


class InstanceContext(OperandContext):
    """The "... Instances" section."""

    def __init__(self, instance, header):
        super().__init__()

        self.instance = instance
        self.header = header

    def __str__(self):
        return "{}({}) # {}".format(
            self.__class__.__name__, self.instance.name, self.header
        )


class ExoticObjectContext(OperandContext):
    """Exotic objects section."""

    def __init__(self, obj, header):
        super().__init__()

        self.obj = obj
        self.header = header

    def __str__(self):
        return "{}({}) # {}".format(
            self.__class__.__name__, self.obj.name, self.header
        )


class ProxyHandlerContext(OperandContext):
    def __init__(self, handler):
        super().__init__()

        self.handler = handler

        self.currentRefTarget = None

    def __str__(self):
        return self.__class__.__name__


# (special case) Intl
# "Locale Sensitive Functions of the ECMAScript Language Specification" section
# contains the functions without the corresponding enclosing section for the
# prototypes.
class LocaleSensitiveFunctionsContext(OperandContext):
    """The "Locale Sensitive Functions" section."""

    def __init__(self):
        super().__init__()

    def __str__(self):
        return self.__class__.__name__


class ContextWith:
    """Context manager for contexts."""

    def __init__(self, context, stack):
        self.context = context
        self.stack = stack

    def __enter__(self):
        self.stack.append(self.context)
        return self

    def __exit__(self, *args):
        context = self.stack.pop()
        if context != self.context:
            raise IDLError(
                "Context mismatch: expected {}, got {}".format(
                    str(self.context), str(context)
                )
            )


class SpecTitles:
    """A map from spec URL to the title."""

    titles = {}

    @classmethod
    def set(cls, specURL, title):
        if specURL in cls.titles:
            raise IDLError("{} must be unique".format(specURL))

        cls.titles[specURL] = title

    @classmethod
    def get(cls, specURL):
        return cls.titles[specURL]


class Patterns:
    def REP0(s):
        return r"(?:" + s + r")*"

    def REP1(s):
        return r"(?:" + s + r")+"

    def MAYBE(s):
        return r"(?:" + s + r")?"

    def GROUP(s):
        return r"(" + s + r")"

    def OR(*args):
        return r"|".join(args)

    Ident = r"[A-Za-z_][A-Za-z0-9_]*"
    Prop = r"\." + Ident
    PropGroup = r"\." + GROUP(Ident)
    SymName = "Symbol\." + Ident + r""
    SymElem = r"\s*\[\s*" + SymName + r"\s*\]"
    SymElemGroup = r"\s*\[\s*" + GROUP(SymName) + r"\s*\]"

    Expr = GROUP(
        Ident + REP0(Prop) + MAYBE(SymElem),
    )

    MemberExpr = GROUP(OR(
        Ident + REP1(Prop) + MAYBE(SymElem),
        Ident + SymElem,
    ))

    P1 = GROUP(Ident + REP0(Prop)) + PropGroup + r"$"
    P2 = GROUP(Ident + REP0(Prop)) + SymElemGroup + r"$"

    @classmethod
    def maybeExtractExpr(cls, expr):
        m = re.match(cls.P1, expr)
        if m:
            return m.group(1), m.group(2)
        m = re.match(cls.P2, expr)
        if m:
            return m.group(1), m.group(2)
        return None, expr


class TreeWalker:
    """A class for walking the spec HTML."""

    contextStack = []

    # Properties of the current spec.
    title = None
    path = None
    specURL = None
    currentNode = None

    inlineTags = [
        "b",
        "code",
        "dfn",
        "em",
        "i",
        "span",
        "strong",
        "sub",
        "sup",
        "var",
        "a",
        "emu-xref",
        "emu-eqn",
        "emu-not-ref",
        "emu-grammar",
        "emu-prodref",
        "emu-val",
        "img",
        "br",
        lxml.etree.Comment,
    ]

    # Tags that can be inline if content is inline.
    neutralTags = [
        "ins",
        "del",
    ]

    listItemContentTags = (
        inlineTags
        + neutralTags
        + [
            "p",
            "ul",
            "ol",
            "emu-alg",
            "emu-note",
        ]
    )

    # Tags that doesn't contribute to the IDL.
    unrelatedTags = [
        lxml.etree.Comment,
        "style",
        "emu-note",
        "emu-grammar",
        "emu-intro",
        "del",
    ]

    # The "type" attributes of elements that doesn't contribute to the IDL.
    unrelatedTypes = [
        "abstract operation",
        # NOTE: Proxy handler should look into this.
        "internal method",
        "host-defined abstract operation",
        "implementation-defined abstract operation",
        "concrete method",
    ]

    unrelatedHeader = [
        # Global
        "URI Handling Functions",
        # Iterators
        "Control Abstraction Objects",
        # (special case) Temporal
        "DateTime Format Functions",
        "Value Format Records",
        "Temporal.Instant range",
    ]

    @classmethod
    def maybeInnermostContext(cls, stack, contextClass):
        """Returns the innermost context which is an instance of contextClass,
        or returns None if there isn't."""

        for item in reversed(stack):
            if isinstance(item, contextClass):
                return item

        return None

    @classmethod
    def maybeCurrentOperandContext(cls):
        return cls.maybeInnermostContext(cls.contextStack, OperandContext)

    @classmethod
    def currentOperandContext(cls):
        context = cls.maybeCurrentOperandContext()
        if context is None:
            raise IDLError("Context should be present")
        return context

    @classmethod
    def hasOperandContext(cls):
        context = cls.maybeCurrentOperandContext()
        return context is not None

    @classmethod
    def currentRefTarget(cls):
        context = cls.maybeInnermostContext(cls.contextStack, RefTargetContext)
        if context is None:
            raise IDLError("RefTargetContext should be present for")
        return context.refTarget

    @classmethod
    def maybeCurrentParsingText(cls):
        context = cls.maybeInnermostContext(cls.contextStack, ParsingTextContext)
        if context is None:
            return None
        return context.text

    @classmethod
    def getTitle(cls, dom, specURL):
        """Find the title definition of the spec."""

        pres = dom.xpath("//pre[@class='metadata']")
        metadataText = str(pres[0].text_content())
        for line in metadataText.split("\n"):
            m = re.match(r"title: '?(.+?)'?$", line.strip())
            if m:
                title = m.group(1).replace("\xa0", " ")
                # Drop the year part from the title to avoid extra diff for each
                # year.
                title = re.sub(r"(ECMAScript®) [0-9]*", "\\1", title)
                SpecTitles.set(specURL, title)

                return title

        raise IDLError("Title not found for {}".format(specURL))

    @classmethod
    def process(cls, dom, path, specURL):
        cls.title = cls.getTitle(dom, specURL)
        cls.path = path
        cls.specURL = specURL

        cls.walk(dom)

        cls.title = None
        cls.path = None
        cls.specURL = None
        cls.currentNode = None

    @classmethod
    def assertSimpleText(cls, node):
        for n in node:
            if n.tag in cls.neutralTags:
                cls.assertSimpleText(n)
            else:
                if n.tag not in cls.inlineTags:
                    raise IDLError(
                        "<{}> should not be inside <{}>".format(n.tag, node.tag)
                    )

    @classmethod
    def handlePropertyListHeader(
        cls, header, entireExpr, isPrototype, isConstructor, refTarget
    ):
        assert "%" not in entireExpr

        target = None

        context = cls.maybeCurrentOperandContext()
        if context is None:
            # (special case) Iterator Prototype
            if entireExpr == "Iterator":
                target = Prototype(entireExpr + " Prototype", refTarget)
            else:
                # Additional properties in the ECMAScript spec, or properties
                # modified by proposals.
                if isPrototype:
                    expr = entireExpr + ".prototype"
                else:
                    expr = entireExpr
                target = evaluateExpression(expr)
        elif isPrototype:
            if isinstance(context, TypedArrayContext):
                if entireExpr == "TypedArray":
                    ctor = context.ctor
                elif entireExpr == "_TypedArray_":
                    ctor = context.ctorTemplate
                else:
                    raise IDLError(
                        "Unsupported target for TypedArray context: {}".format(entireExpr)
                    )
            elif isinstance(context, LocaleSensitiveFunctionsContext):
                ctor = evaluateExpression(entireExpr)
            elif isinstance(context, MultipleObjectContext):
                ctor = context.ctor
                if ctor.name == entireExpr:
                    pass
                elif ctor.qualifiedName == entireExpr:
                    pass
                else:
                    raise IDLError(
                        "Object name mismatch, expected {}, got {}".format(
                            ctor.name, entireExpr
                        )
                    )
            else:
                raise IDLError("Unsupported context for properties: {}".format(context))

            if ctor is None:
                raise IDLError(
                    'Constructor for "{}" prototype must have been defined'.format(entireExpr)
                )

            target = ctor.ensurePrototype(refTarget)

            if isinstance(context, MultipleObjectContext):
                context.proto = target
        elif isinstance(context, TypedArrayContext):
            if isConstructor:
                if entireExpr != "_TypedArray_":
                    raise IDLError(
                        "Unsupported target for TypedArray context: {}".format(entireExpr)
                    )

                target = context.ctorTemplate
            else:
                if entireExpr != "TypedArray":
                    raise IDLError(
                        "Unsupported target for TypedArray context: {}".format(entireExpr)
                    )

                target = context.ctor
        elif isConstructor and isinstance(context, MultipleObjectContext):
            target = context.ctor
            if target.name == entireExpr:
                pass
            elif target.qualifiedName == entireExpr:
                pass
            else:
                raise IDLError(
                    "Constructor name mismatch, expected {}, got {}".format(
                        target.name, entireExpr
                    )
                )
        else:
            if not isinstance(context, SingletonObjectContext):
                raise IDLError(
                    "Expected SingletonObjectContext, got {}".format(str(context))
                )

            target = context.singleton

            if "Temporal." + target.name == entireExpr:
                # (special case) Temporal
                pass
            elif target.name != entireExpr:
                raise IDLError(
                    "Object name mismatch, expected {}, got {}".format(
                        target.name, entireExpr
                    )
                )

        if target is None:
            raise IDLError(
                "Target of properties must be defined : {}".format(entireExpr)
            )

        return PropertyListContext(target, header, refTarget)

    @classmethod
    def handleObjectHeader(
        cls, header, entireExpr, isPrototype, isMultiple, refTarget
    ):
        assert "%" not in entireExpr

        parentExpr, name = Patterns.maybeExtractExpr(entireExpr)

        context = cls.maybeCurrentOperandContext()
        if context and isinstance(context, TypedArrayContext):
            if name != "TypedArray":
                raise IDLError(
                    "Unsupported target for TypedArray context: {}".format(name)
                )

            if context.ctor is not None:
                raise IDLError("{} cannot be overwritten".format(name))

            value = Constructor("TypedArray", refTarget)
            value.setObjectsRefTarget(refTarget)
            context.ctor = value

            NamedObjects.add(value)
            return None

        if isMultiple:
            return MultipleObjectContext(name, entireExpr, header, refTarget)

        value = None
        if parentExpr is None and " " not in name:
            value = evaluateExpression(name, allowUndefined=True)

        if re.match(r".+Prototype$", name):
            isPrototype = True

        if value:
            pass
        elif isPrototype:
            value = Prototype(name, refTarget)
            if isinstance(context, MultipleObjectContext):
                context.proto = value
        else:
            value = SingletonObject(name, refTarget)

        if parentExpr is None:
            NamedObjects.add(value)
        else:
            parent = evaluateExpression(parentExpr)

            if not parent.hasProperty(name):
                raise IDLError(
                    'Target must have "{}" property : {}'.format(name, parentExpr)
                )

            refValue = parent.getProperty(name).value

            if isinstance(refValue, URIReferenceValue):
                refURI = refValue.refTarget.toURI()
                uri = refTarget.toURI()
                if refURI != uri:
                    raise IDLError(
                        "Reference target mismatch, expected {}, got {}".format(refURI, uri)
                    )
            elif isinstance(refValue, ExpressionReferenceValue):
                pass
            else:
                raise IDLError("Property {} must have been defined as reference".format(entireExpr))

            NamedObjects.addWith(value, entireExpr)

        if isPrototype:
            return PrototypeObjectContext(value, header)
        return SingletonObjectContext(value, header)

    @classmethod
    def handleConstructorListHeader(
        cls, header, entireExpr, refTarget
    ):
        assert "%" not in entireExpr

        parentExpr, name = Patterns.maybeExtractExpr(entireExpr)

        context = cls.maybeCurrentOperandContext()
        if context is None:
            if entireExpr == "Intl.DateTimeFormat":
                # (special case) Temporal
                # Temporal contains the update for Intl.DateTimeFormat without
                # corresponding enclosing section.
                value = evaluateExpression(entireExpr)
            elif parentExpr is not None:
                raise IDLError(
                    'Context must be present for constructor property "{}"'.format(
                        entireExpr
                    )
                )
            else:
                value = evaluateExpression(name)
        elif isinstance(context, TypedArrayContext):
            if name != "_TypedArray_":
                raise IDLError(
                    "Unsupported target for TypedArray context: {}".format(name)
                )

            value = Constructor(name, refTarget)
            value.setObjectsRefTarget(context.refTarget)
            context.ctorTemplate = value

            NamedObjects.add(value)
        else:
            if not isinstance(context, MultipleObjectContext):
                raise IDLError(
                    "Expected MultipleObjectContext, got {}".format(str(context))
                )

            if context.name != name:
                raise IDLError(
                    "Object name mismatch, expected {}, got {}".format(
                        value.name, parentExpr
                    )
                )

            value = Constructor(name, refTarget)
            value.setObjectsRefTarget(context.objectsRefTarget)
            context.ctor = value

            NamedObjects.addWith(value, entireExpr)

        if parentExpr:
            parent = evaluateExpression(parentExpr)

            if not parent.hasProperty(name):
                raise IDLError(
                    'Property "{}" must exist in {}'.format(name, parentExpr)
                )

            prop = parent.props[name]
            value.setParent(parent, name)
            prop.value = value

            if isinstance(context, MultipleObjectContext):
                context.qualifiedName = value.qualifiedName

        return ConstructorListContext(value, header)

    @classmethod
    def handleFunctionHeader(cls, header, name, params, refTarget):
        assert "%" not in name

        context = cls.maybeCurrentOperandContext()
        if context is None:
            return

        if isinstance(context, TypedArrayContext):
            if name == "TypedArray":
                ctor = context.ctor
            elif name == "_TypedArray_":
                ctor = context.ctorTemplate
            else:
                raise IDLError(
                    "Unsupported target for TypedArray context: {}".format(name)
                )

            if ctor is None:
                raise IDLError('Constructor "{}" must have been defined'.format(name))

            ctor.setParams(ParameterList(params))
            return ConstructorContext(ctor, header)

        if isinstance(context, ConstructorListContext):
            ctor = context.ctor
            if ctor.name != name:
                raise IDLError(
                    "Constructor name mismatch, expected {}, got {}".format(
                        ctor.name, name
                    )
                )

            ctor.setParams(ParameterList(params))
            return ConstructorContext(ctor, header)

        if not isinstance(context, PropertyListContext):
            raise IDLError("Expected PropertyListContext : {}".format(str(context)))

        target = context.obj
        if target.name != "Global":
            raise IDLError("Standalone function must be global propety")

        if params == " . . . ":
            value = None
        else:
            value = Function(name, refTarget)
            value.setParams(ParameterList(params))

            logger.debug('Create function for "{}" property'.format(name))

        prop = Property(target, name, value, refTarget)
        target.setProperty(name, prop)

        return PropertyContext(target, prop, header)

    @classmethod
    def validateInitialValueTarget(cls, owner, prop, expr):
        name = owner.name
        name = name.replace(" Prototype", ".prototype")
        name = name.replace(" constructor", ".constructor")

        if name == "Global":
            actualExpr = prop.name
        elif prop.name.startswith("Symbol."):
            actualExpr = name + "[" + prop.name + "]"
        else:
            actualExpr = name + "." + prop.name

        # (special case) Async Iterator Helpers
        #expr = expr.replace("AsyncIterator.prototype", "AsyncIteratorPrototype")
        #actualExpr = actualExpr.replace(
        #    "AsyncIterator.prototype", "AsyncIteratorPrototype"
        #)

        if actualExpr == expr:
            pass
        elif actualExpr.endswith("." + expr):
            pass
        elif expr.endswith("." + actualExpr):
            pass
        else:
            raise IDLError(
                "Target of initial value mismatch. Expected {}, got {}".format(
                    actualExpr, expr
                )
            )

    @classmethod
    def validatePropertyTarget(cls, target, expr):
        if target.name == expr:
            pass
        elif target.qualifiedName == expr:
            pass
        elif expr.endswith("." + target.name):
            pass
        elif target.qualifiedName is not None and expr.endswith(
            "." + target.qualifiedName
        ):
            pass
        elif target.name.replace(" Prototype", ".prototype") == expr:
            pass
        elif target.name.replace("Prototype", ".prototype") == expr:
            pass
        else:
            raise IDLError(
                "Target of property mismatch for {}, got {}".format(target.name, expr)
            )

    @classmethod
    def handlePropertyHeader(
        cls, header, kind, entireExpr, params, refTarget
    ):
        assert "%" not in entireExpr

        parentExpr, propName = Patterns.maybeExtractExpr(entireExpr)
        assert parentExpr is not None

        target = None

        context = cls.maybeCurrentOperandContext()
        if context is None:
            # (special case) Async Iterator Helpers
            if parentExpr == "AsyncIterator" and propName == "prototype":
                ctor = evaluateExpression(parentExpr)
                target = ctor.ensurePrototype(refTarget)

                if isinstance(context, MultipleObjectContext):
                    context.proto = target

                return PropertyListContext(target, header, refTarget)

            if parentExpr.endswith(".prototype"):
                target = evaluateExpression(parentExpr)
            elif parentExpr == "Uint8Array":
                # (special case) Uint8Array to/from base64
                # This proposal contains the update for Uint8Array properties
                # without corresponding enclosing section.
                target = evaluateExpression(parentExpr)
            else:
                raise IDLError("Context should be present for: {}".format(header))
        elif isinstance(context, PropertyListContext):
            target = context.obj
        elif isinstance(context, SingletonObjectContext):
            target = context.singleton
        elif isinstance(context, PrototypeObjectContext):
            target = context.proto
        elif isinstance(context, TypedArrayContext):
            if parentExpr != "TypedArray":
                raise IDLError(
                    "Unsupported target for TypedArray context: {}".format(parentExpr)
                )

            target = context.ctor
        elif isinstance(context, PropertyContext):
            if kind is None:
                raise IDLError("Property inside Property must be accessor")

            prop = context.prop

            if kind == "get":
                prop.hasGetter = True
            elif kind == "set":
                prop.hasSetter = True

            return
        elif isinstance(context, ConstructorListContext):
            target = context.ctor
            if target.name != propName:
                raise IDLError(
                    "Constructor name mismatch, expected {}, got {}".format(
                        target.name, propName
                    )
                )

            target.setParams(ParameterList(params))
            return ConstructorContext(target, header)
        elif isinstance(context, ExoticObjectContext):
            target = context.obj
        elif isinstance(context, InstanceContext):
            target = context.instance
        else:
            raise IDLError("Unexpected context for property : {}".format(str(context)))

        if target is None:
            raise IDLError(
                "Target of properties must be defined : {}".format(entireExpr)
            )

        cls.validatePropertyTarget(target, parentExpr)

        if target.hasProperty(propName):
            prop = target.getProperty(propName)

            if params:
                if not isinstance(prop.value, Function):
                    raise IDLError(
                        'Parameters cannot be specified for existing non-function property "{}"'.format(
                            propName
                        )
                    )

                newParams = ParameterList(params)

                if str(newParams) != str(prop.value.params):
                    prop.value.params = newParams
                    prop.value.setRefTarget(refTarget)
                    prop.refTarget = refTarget
        else:
            if params == " . . . ":
                value = None
            elif params:
                value = Function(propName, refTarget)
                value.setParams(ParameterList(params))

                logger.debug('Create function for "{}" property'.format(propName))
            elif kind:
                value = Function(propName, refTarget)

                logger.debug("Create accessor for {} property".format(propName))
            else:
                logger.debug('Create generic property "{}"'.format(propName))
                value = None

            prop = Property(target, propName, value, refTarget)
            target.setProperty(propName, prop)

        if kind == "get":
            prop.hasGetter = True
        elif kind == "set":
            prop.hasSetter = True

        return PropertyContext(target, prop, header)

    @classmethod
    def handleNameHeader(cls, header, name, refTarget):
        assert "%" not in name

        context = cls.maybeCurrentOperandContext()
        if context is None:
            return

        if isinstance(context, PropertyListContext):
            target = context.obj
            if target.name != "Global":
                raise IDLError("Standalone name must be global propety")

            prop = Property(target, name, None, refTarget)
            target.setProperty(name, prop)

            logger.debug('Create name property "{}"'.format(name))

            return PropertyContext(target, prop, header)

        if isinstance(context, NativeErrorContext):
            value = TemplateInstantiation("_NativeError_", name, refTarget)

            logger.debug(
                "Create template instantiation for _NativeError_ as {}".format(name)
            )
            return NativeErrorTemplateInstantiationContext(value, header)

        if isinstance(context, InstanceContext):
            target = context.instance

            prop = Property(target, name, Value(None, refTarget), refTarget)
            if prop.safeName == "_prototype_":
                prop.safeName = "_prototype_2_"
            target.setProperty(name, prop)

            logger.debug('Create name property "{}"'.format(name))

            return InstancePropertyContext(target, prop, header)

        if isinstance(context, MultipleObjectContext):
            return

        if isinstance(context, ExoticObjectContext):
            target = context.obj

            prop = Property(target, name, Value(None, refTarget), refTarget)
            target.setProperty(name, prop)

            logger.debug('Create name property "{}"'.format(name))

            return InstancePropertyContext(target, prop, header)

        raise IDLError("Unhandled name header in {}".format(str(context)))

    @classmethod
    def handleInstanceHeader(cls, header, entireExpr, refTarget):
        assert "%" not in entireExpr

        parentExpr, name = Patterns.maybeExtractExpr(entireExpr)

        ctor = None
        proto = None

        context = cls.maybeCurrentOperandContext()
        if context is None:
            if entireExpr == "Intl.DateTimeFormat":
                # (special case) Temporal
                # Temporal contains the update for Intl.DateTimeFormat without
                # corresponding enclosing section.
                proto = evaluateExpression(entireExpr + ".prototype")
            else:
                raise IDLError(
                    "Context must be present for instance: {}".format(entireExpr)
                )
        elif isinstance(context, TypedArrayContext):
            if name != entireExpr:
                raise IDLError(
                    "TypedArray name must be top-level: {}".format(entireExpr)
                )

            if name != "_TypedArray_":
                raise IDLError(
                    "Unsupported target for TypedArray context: {}".format(name)
                )

            ctor = context.ctorTemplate
            if ctor is None:
                raise IDLError("{} must have been defined".format(name))

            if ctor.name != name:
                raise IDLError(
                    "Instance name mismatch, expected {}, got {}".format(
                        ctor.name, name
                    )
                )

            proto = ctor.getPrototype()
        elif isinstance(context, MultipleObjectContext):
            if context.name == entireExpr:
                pass
            elif context.qualifiedName == entireExpr:
                pass
            else:
                raise IDLError(
                    "Instance name mismatch, expected {}{}, got {}".format(
                        context.name,
                        " or {}".format(context.qualifiedName)
                        if context.qualifiedName
                        else "",
                        entireExpr
                    )
                )

            proto = context.proto
        elif isinstance(context, PrototypeObjectContext):
            proto = context.proto

            # (special case) Iterators without constructor
            if entireExpr == "RegExp String Iterator" and proto.name == "RegExpStringIteratorPrototype":
                pass
            elif entireExpr == "Array Iterator" and proto.name == "ArrayIteratorPrototype":
                pass
            elif entireExpr == proto.name:
                pass
            else:
                raise IDLError(
                    "Instance name mismatch, expected {}, got {}".format(
                        proto.name, entireExpr
                    )
                )
        else:
            raise IDLError("Unexpected context for instance : {}".format(str(context)))

        if proto and proto.hasInstance():
            value = proto.getInstance()
        else:
            value = InstanceObject(name + " Instance", refTarget)
            if proto:
                proto.setInstance(value)
            else:
                raise IDLError("Instance for {} needs a prototype : {}".format(name, str(context)))

        return InstanceContext(value, header)

    @classmethod
    def handleExoticObjectHeader(cls, header, entireExpr, refTarget):
        assert "%" not in entireExpr

        if entireExpr == "Module Namespace":
            entireExpr = "ModuleNamespace"

        value = ExoticObject(entireExpr, refTarget)

        NamedObjects.addWith(value, entireExpr)

        return ExoticObjectContext(value, header)

    @classmethod
    def handleHeader(cls, clause, header):
        refTarget = RefTarget(cls.specURL, clause.get("id"), header)

        if header in cls.unrelatedHeader:
            return None

        if header == "TypedArray Objects":
            return TypedArrayContext(cls.currentRefTarget(), header)

        if header == "Native Error Types Used in This Standard":
            return NativeErrorContext(header)

        m = re.match(
            r"%(Symbol\." + Patterns.Ident + r")%$",
            header,
        )
        if m:
            name = m.group(1)

            return cls.handleNameHeader(header, name, refTarget)

        headerNoIntrinsicSign = header.replace("%", "")

        PropPrefix = r"(?:Value |Function |Constructor |Additional |Other )?"
        m = re.match(
            PropPrefix + r"Properties of (?:the )?" + Patterns.Expr + r" (?:Objects?|Intrinsic Object)$",
            headerNoIntrinsicSign,
        )
        if m:
            entireExpr = m.group(1)
            isConstructor = False
            isPrototype = False

            return cls.handlePropertyListHeader(
                header,
                entireExpr,
                isPrototype,
                isConstructor,
                refTarget,
            )

        m = re.match(
            PropPrefix + r"Properties of (?:the )?" + Patterns.Expr + r" Prototype Objects?$",
            headerNoIntrinsicSign,
        )
        if m:
            entireExpr = m.group(1)
            isConstructor = False
            isPrototype = True

            return cls.handlePropertyListHeader(
                header,
                entireExpr,
                isPrototype,
                isConstructor,
                refTarget,
            )

        m = re.match(
            PropPrefix + r"Properties of (?:the )?" + Patterns.Expr + r" Constructors?$",
            headerNoIntrinsicSign,
        )
        if m:
            entireExpr = m.group(1)
            isConstructor = True
            isPrototype = False

            return cls.handlePropertyListHeader(
                header,
                entireExpr,
                isPrototype,
                isConstructor,
                refTarget,
            )

        m = re.match(
            r"The (" + Patterns.Expr + r".prototype) Object$",
            headerNoIntrinsicSign,
        )
        if m:
            entireExpr = m.group(1)
            isPrototype = True
            isMultiple = False

            return cls.handleObjectHeader(
                header, entireExpr, isPrototype, isMultiple, refTarget
            )

        m = re.match(
            r"The " + Patterns.Expr + r" (?:Object|Intrinsic Object)$",
            headerNoIntrinsicSign,
        )
        if m:
            entireExpr = m.group(1)
            isPrototype = False
            isMultiple = False

            return cls.handleObjectHeader(
                header, entireExpr, isPrototype, isMultiple, refTarget
            )

        m = re.match(
            Patterns.Expr + r" (?:Objects|Object Structure)$",
            headerNoIntrinsicSign,
        )
        if m:
            entireExpr = m.group(1)
            isPrototype = False
            isMultiple = True

            return cls.handleObjectHeader(
                header, entireExpr, isPrototype, isMultiple, refTarget
            )

        if header == "RegExp (Regular Expression) Objects":
            entireExpr = "RegExp"
            isPrototype = False
            isMultiple = True

            return cls.handleObjectHeader(
                header, entireExpr, isPrototype, isMultiple, refTarget
            )

        if header == "Module Namespace Objects":
            entireExpr = "Module Namespace"

            return cls.handleExoticObjectHeader(
                header, entireExpr, refTarget
            )

        m = re.match(
            r"(.+ Iterator) Objects$",
            headerNoIntrinsicSign,
        )
        if m:
            entireExpr = m.group(1)
            isPrototype = False
            isMultiple = True

            return cls.handleObjectHeader(
                header, entireExpr, isPrototype, isMultiple, refTarget
            )

        m = re.match(
            r"The " + Patterns.Expr + r" (Constructor|Constructors)$",
            headerNoIntrinsicSign,
        )
        if m:
            entireExpr = m.group(1)

            return cls.handleConstructorListHeader(
                header, entireExpr, refTarget
            )

        m = re.match(
            Patterns.MemberExpr + r"(?:\s*\((.*)\))$",
            headerNoIntrinsicSign,
        )
        if m:
            entireExpr, params = m.groups()
            kind = None

            return cls.handlePropertyHeader(
                header, kind, entireExpr, params, refTarget
            )

        m = re.match(
            r"(get|set) " + Patterns.MemberExpr,
            headerNoIntrinsicSign,
        )
        if m:
            kind, entireExpr = m.groups()
            params = None

            return cls.handlePropertyHeader(
                header, kind, entireExpr, params, refTarget
            )

        m = re.match(
            Patterns.MemberExpr,
            headerNoIntrinsicSign,
        )
        if m:
            entireExpr = m.group(1)
            kind = None
            params = None

            return cls.handlePropertyHeader(
                header, kind, entireExpr, params, refTarget
            )

        m = re.match(
            Patterns.GROUP(Patterns.Ident) + r"(?:\s*\((.*)\))$",
            headerNoIntrinsicSign,
        )
        if m:
            name, params = m.groups()

            return cls.handleFunctionHeader(header, name, params, refTarget)

        m = re.match(
            Patterns.GROUP(Patterns.Ident) + r"$",
            headerNoIntrinsicSign,
        )
        if m:
            name = m.group(1)

            return cls.handleNameHeader(header, name, refTarget)

        m = re.match(
            r"Legacy " + Patterns.Expr + r" Accessor Methods$",
            headerNoIntrinsicSign,
        )
        if m:
            entireExpr = m.group(1)

            context = cls.currentOperandContext()
            if not isinstance(context, PropertyListContext):
                raise IDLError(
                    "Legacy methods in unexpected context : {}".format(context)
                )

            if entireExpr != context.obj.qualifiedName:
                raise IDLError(
                    "Object name mismatch, expected {}, got {}".format(
                        context.obj.qualifiedName, entireExpr
                    )
                )

            return None

        m = re.match(
            r"Properties of " + Patterns.Expr + r" Instances$",
            headerNoIntrinsicSign,
        )
        if m:
            entireExpr = m.group(1)

            return cls.handleInstanceHeader(header, entireExpr, refTarget)

        m = re.match(
            r"Properties of (.+ Iterator) Instances$",
            headerNoIntrinsicSign,
        )
        if m:
            entireExpr = m.group(1)

            return cls.handleInstanceHeader(header, entireExpr, refTarget)

        m = re.match(
            Patterns.Expr + r" Instances$",
            headerNoIntrinsicSign,
        )
        if m:
            entireExpr = m.group(1)

            return cls.handleInstanceHeader(header, entireExpr, refTarget)

        if (
            header
            == "Locale Sensitive Functions of the ECMAScript Language Specification"
        ):
            return LocaleSensitiveFunctionsContext()

        if (
            header
            == "Proxy Object Internal Methods and Internal Slots"
        ):
            value = Dictionary("ProxyHandler", refTarget)

            NamedObjects.add(value)

            return ProxyHandlerContext(value)

        context = cls.maybeCurrentOperandContext()
        if context is None:
            return None

        if isinstance(context, MultipleObjectContext):
            return None
        if isinstance(context, SingletonObjectContext):
            return None
        if isinstance(context, PropertyContext):
            return None
        if isinstance(context, InstanceContext):
            return None
        if isinstance(context, ProxyHandlerContext):
            context.currentRefTarget = refTarget
            return None

        raise IDLError("Unhandled header in {}: {}".format(str(context), header))

    @classmethod
    def handleIntrinsicExpr(cls, targetName, expr):
        assert "%" not in expr

        context = cls.currentOperandContext()

        target = None
        if isinstance(context, ConstructorListContext):
            target = context.ctor
        elif isinstance(context, PropertyListContext):
            target = context.obj
        elif isinstance(context, SingletonObjectContext):
            target = context.singleton
        elif isinstance(context, PrototypeObjectContext):
            target = context.proto
        elif isinstance(context, PropertyContext):
            target = context.prop.getValue()
            if target is None:
                raise IDLError(
                    "Property value must be defined for intrinsic name : {}".format(
                        targetName
                    )
                )
        elif isinstance(context, NativeErrorTemplateInstantiationContext):
            target = context.ctor
        else:
            raise IDLError("Unhandled intrinsic name in {}".format(str(context)))

        if targetName:
            if target.name == targetName:
                pass
            elif target.qualifiedName == targetName:
                pass
            else:
                raise IDLError(
                    "Object name mismatch, expected {}, got {}".format(
                        target.name, targetName
                    )
                )

        NamedObjects.addWith(target, expr)

    @classmethod
    def handlePrototypeSlot(cls, expr):
        context = cls.currentOperandContext()

        target = None
        if isinstance(context, ConstructorListContext):
            target = context.ctor
        elif isinstance(context, PropertyListContext):
            target = context.obj
        elif isinstance(context, SingletonObjectContext):
            target = context.singleton
        elif isinstance(context, MultipleObjectContext):
            target = context.singleton
        elif isinstance(context, PrototypeObjectContext):
            target = context.proto
        else:
            raise IDLError("Unhandled [[Prototype]] in {}".format(str(context)))

        target.setPrototypeSlot(expr)

    @classmethod
    def handleExoticObject(cls):
        context = cls.currentOperandContext()

        target = None
        if isinstance(context, PropertyListContext):
            target = context.obj
        else:
            raise IDLError("Unhandled exotic object in {}".format(str(context)))

        target.isCustom = True

    @classmethod
    def maybeHandleListItem(cls, node):
        text = str(node.text_content()).strip()

        with cls.parsingText(text):
            cls.maybeHandleListItemText(text)

    @classmethod
    def handleGlobalProperty(cls, name):
        context = cls.currentOperandContext()

        globalValue = NamedObjects.get("Global")
        if globalValue is None:
            raise IDLError("Global must be defined before defining variables")

        if globalValue.hasProperty(name):
            prop = globalValue.getProperty(name)
            assert prop.value

            if not isinstance(prop.value, URIReferenceValue):
                raise IDLError(
                    "Global propety must be an URI reference : {}".format(name)
                )

            refValue = prop.value

            if isinstance(context, ConstructorListContext):
                if context.ctor.name != name:
                    raise IDLError(
                        "Constructor name mismatch, expected {}, got {}".format(
                            refValue, name
                        )
                    )

                refURI = refValue.refTarget.toURI()
                ctorURI = context.ctor.refTarget.toURI()
                objURI = context.ctor.objectsRefTarget.toURI()

                if refURI != ctorURI and refURI != objURI:
                    raise IDLError(
                        "Reference target mismatch, expected {}, got {} or {}".format(
                            refURI, ctorURI, objURI
                        )
                    )
                return

            if isinstance(context, SingletonObjectContext):
                if context.singleton.name != name:
                    raise IDLError(
                        "Object name mismatch, expected {}, got {}".format(
                            refValue.expr, name
                        )
                    )

                refURI = refValue.refTarget.toURI()
                objURI = context.singleton.refTarget.toURI()

                if refURI != objURI:
                    raise IDLError(
                        "Reference target mismatch, expected {}, got {}".format(
                            refURI, objURI
                        )
                    )
                return

        if isinstance(context, ConstructorListContext):
            if context.ctor.name != name:
                raise IDLError(
                    "Constructor name mismatch, expected {}, got {}".format(
                        refValue.expr, name
                    )
                )
            refTarget = context.ctor.refTarget
        elif isinstance(context, SingletonObjectContext):
            if context.singleton.name != name:
                raise IDLError(
                    "Object name mismatch, expected {}, got {}".format(
                        refValue.expr, name
                    )
                )
            refTarget = context.singleton.refTarget
        else:
            raise IDLError(
                "Expected context for global property : {}".format(str(context))
            )

        refValue = URIReferenceValue(refTarget)
        prop = Property(globalValue, name, refValue, refTarget)
        globalValue.setProperty(name, prop)

    @classmethod
    def handleGlobalPropertyListItem(cls, name):
        context = cls.currentOperandContext()

        globalValue = NamedObjects.get("Global")
        if globalValue is None:
            raise IDLError("Global must be defined before defining variables")

        if not globalValue.hasProperty(name):
            raise IDLError("Global must have {} property".format(name))

        prop = globalValue.getProperty(name)

        if isinstance(context, ConstructorListContext):
            value = context.ctor
        elif isinstance(context, SingletonObjectContext):
            value = context.singleton
        else:
            raise IDLError(
                "Expected context for global property : {}".format(str(context))
            )

        if value != prop.getValue():
            raise IDLError("Global property {} must agree".format(name))

    @classmethod
    def handleIsNotFunction(cls):
        context = cls.currentOperandContext()

        if isinstance(context, SingletonObjectContext):
            obj = context.singleton
        else:
            raise IDLError(
                "Expected context for non-function : {}".format(str(context))
            )

        if isinstance(obj, Function):
            raise IDLError(
                "Expected non-function object, got {}".format(
                    context.obj
                )
            )

    @classmethod
    def handleIsFunction(cls):
        context = cls.currentOperandContext()

        if isinstance(context, PropertyListContext):
            obj = context.obj
        else:
            raise IDLError(
                "Expected context for function : {}".format(str(context))
            )

        if isinstance(obj, Prototype):
            obj.isCustom = True
            return

        if not isinstance(obj, Function):
            raise IDLError(
                "Expected function object, got {}".format(
                    obj
                )
            )

    @classmethod
    def handleIsFunctionSubClass(cls):
        context = cls.currentOperandContext()

        if isinstance(context, ConstructorListContext):
            obj = context.ctor
        else:
            raise IDLError(
                "Expected context for function subclass : {}".format(str(context))
            )

        obj.setPrototypeSlot("Function")

    @classmethod
    def handleIsNonDefaultObject(cls):
        context = cls.currentOperandContext()

        if isinstance(context, PropertyListContext):
            obj = context.obj
        else:
            raise IDLError(
                "Expected context for non-default object : {}".format(str(context))
            )

        obj.isCustom = True

    @classmethod
    def maybeHandleListItemText(cls, text):
        m = re.match(
            r"is the initial value of the \*\"([A-Za-z_][A-Za-z0-9_]*)\"\* property of the global object.",
            text,
        )
        if m:
            name = m.group(1)

            cls.handleGlobalProperty(name)

        m = re.match(r"is (?:the intrinsic object )?%(.+)%", text)
        if m:
            expr = m.group(1)

            cls.handleIntrinsicExpr(None, expr)
            return

        m = re.match(
            r"has a \[\[Prototype\]\] internal slot whose value is (?:the intrinsic object )?%([A-Za-z_][A-Za-z0-9_]*(?:\.[A-Za-z_][A-Za-z0-9_]*)*)%\.",
            text,
        )
        if m:
            expr = m.group(1)

            cls.handlePrototypeSlot(expr)
            return

        if text == "has a [[Prototype]] internal slot whose value is *null*.":
            cls.handlePrototypeSlot("null")
            return

        if text == "has a [[Prototype]] internal slot whose value is host-defined.":
            # (special case) Global
            return

        m = re.match(
            r"is an? .+ exotic object",
            text,
        )
        if m:
            cls.handleExoticObject()
            return

        m = re.match(
            r"has a \*\"length\"\* property whose (?:initial )?value is \*\+?([0-9]+)\*𝔽(?: and whose attributes are \{(.+)\})?.",
            text,
        )
        if m:
            length = m.group(1)
            attrsText = m.group(2)
            if attrsText:
                attrs = Attributes.fromText(attrsText)
            else:
                attrs = DefaultAttributes()

            cls.handleLengthProperty(int(length), attrs)
            return

        m = re.match(
            r"has a \*\"name\"\* property whose value is \*\"(.+)\"\*\.",
            text,
        )
        if m:
            name = m.group(1)

            cls.handleNameProperty(name)
            return

        m = re.match(
            r"has a \*\"name\"\* property whose value is the String value \"(.+)\"\.",
            text,
        )
        if m:
            name = m.group(1)

            cls.handleNameProperty(name)
            return

        m = re.match(
            r"has a \*\"name\"\* property whose value is the empty String\.",
            text,
        )
        if m:
            cls.handleNameProperty("")
            return

        m = re.match(r"is a constructor function", text)
        if m:
            context = cls.currentOperandContext()
            if not isinstance(context, TypedArrayContext):
                raise IDLError("Unsupported item : {}".format(text))

            if context.ctor is None:
                raise IDLError("TypedArray Constructor must be defined")

            if context.ctorTemplate is not None:
                raise IDLError("_TypedArray_ Constructor must not be defined")

            return

        if text == "is a standard built-in function object that inherits from the Function constructor.":
            cls.handleIsFunction()
            return

        if text == "is itself a built-in function object.":
            cls.handleIsFunction()
            return

        if text == "is a subclass of `Function`.":
            cls.handleIsFunctionSubClass()
            return

        if text in [
                "is an ordinary object.",
                "is itself an ordinary object.",
                "has the following properties:",
                "has the following additional properties:",
                "is not intended to be called as a function and will throw an exception when called in that manner.",
                "is not intended to be subclassed.",
        ]:
            return

        if text == "is never directly accessible to ECMAScript code.":
            # ForInIteratorPrototype
            return

        if text == "is not a function object.":
            cls.handleIsNotFunction()
            return


        if re.match(r"is created before", text):
            # Global
            return

        if re.match(r"is not intended to be used with the `new` operator", text):
            # Symbol and BigInt
            return

        if re.match(r"is not an? .+ (instance|object)", text):
            return

        if re.match(r"is the prototype of all .+ objects", text):
            # IntlSegmentsPrototype
            # IntlSegmentIteratorPrototype
            return

        if re.match(r"is not a function object and does not have an", text):
            # AsyncFunction Prototype
            # GeneratorFunction Prototype
            # AsyncGeneratorFunction Prototype
            return

        if re.match(r"is designed to be subclassable", text):
            # Iterator
            return

        if re.match(r"is a function whose behaviour differs based upon the number and types of its arguments", text):
            # Date, Array, TypedArray
            return

        if re.match(r"is an intrinsic object that has the structure described below", text):
            # TypedArray
            return

        if re.match(r"has properties that are (?:indirectly )?inherited by all .+ (objects|instances).", text):
            # prototype-only objects
            return

        if re.match(r"has a \*\"name\"\* property whose value is the String value of the constructor name specified for it in ", text):
            # TypedArray
            return

        if text == "has a [[StringData]] internal slot whose value is the empty String.":
            # String Prototype
            return

        if text == "has an [[Extensible]] internal slot whose value is *true*.":
            # Object Prototype

            cls.handleIsNonDefaultObject()
            return

        m = re.match(r"is the initial value of the \*\"(.+)\"\* property of the global object.", text)
        if m:
            name = m.group(1)

            cls.handleGlobalPropertyListItem(name)
            return

        m = re.match(r"is itself an? (.+) object", text)
        if m:
            cls.handleIsNonDefaultObject()
            return

        if text == "has the internal methods defined for ordinary objects, except for the [[SetPrototypeOf]] method, which is as defined in . (Thus, it is an immutable prototype exotic object.)":
            # Object Prototype
            return

        if re.match(r"is ", text):
            raise IDLError("Unhandled list item with \"is \": {}".format(text))

        if re.match(r"has ", text):
            raise IDLError("Unhandled list item with \"has \": {}".format(text))

    @classmethod
    def handleUnscopables(cls, node, context):
        text = str(node.text_content()).strip()

        names = []
        for line in text.split("\n"):
            m = re.search(
                r"CreateDataPropertyOrThrow\(_unscopableList_, \*\"([^\"]+)\"\*, \*true\*\)",
                line,
            )
            if m:
                name = m.group(1)
                names.append(name)

        if len(names) == 0:
            raise IDLError("Unscopable names not found")

        value = UnscopablesValue(names, context.prop.refTarget)
        context.prop.setValue(value)

    @classmethod
    def handleProxyHandlerAlgorithm(cls, node, context):
        text = str(node.text_content()).strip()

        name = None
        for line in text.split("\n"):
            m = re.search(
                r"GetMethod\(_handler_, \*\"(.+)\"\*\)",
                line,
            )
            if m:
                name = m.group(1)

            m = re.search(
                r"Call\(_trap_, _handler_, «(.*)»\)",
                line,
            )
            if m:
                params = m.group(1)

        if name is None or params is None:
            raise IDLError("handler method not found")

        value = Callback(name, "{}Callback".format(name), context.currentRefTarget)
        value.setParams(ParameterList(params))
        prop = DictionaryMember(context.handler, name, value, context.currentRefTarget)
        context.handler.setProperty(name, prop)

        prop.optional = True

        NamedObjects.add(value)

    @classmethod
    def maybeHandleAlgorithm(cls, node):
        context = cls.maybeCurrentOperandContext()
        if context is None:
            return

        if isinstance(context, PropertyContext):
            prop = context.prop
            if prop.name == "Symbol.unscopables":
                cls.handleUnscopables(node, context)
                return

        if isinstance(context, ProxyHandlerContext):
            cls.handleProxyHandlerAlgorithm(node, context)
            return

    @classmethod
    def handleAttributes(cls, attrs):
        context = cls.currentOperandContext()
        if not isinstance(context, PropertyContext):
            raise IDLError(
                "Attributes found in unexpected context : {}".format(context)
            )

        context.prop.setAttributes(Attributes.fromText(attrs))

    @classmethod
    def handleExplicitLength(cls, target, length):
        if target != "function" and target != "method":
            raise IDLError("Unhandled target {}".format(target))

        context = cls.currentOperandContext()

        value = None
        if isinstance(context, PropertyContext):
            value = context.prop.getValue()
            if value is None or not isinstance(value, Function):
                raise IDLError("The target of explicit length must be a function : {}".format(value))
        elif isinstance(context, ConstructorContext):
            value = context.ctor
        elif isinstance(context, PropertyListContext):
            value = context.obj
        else:
            raise IDLError("Unhandled context for explicit length : {}".format(context))

        value.setExplicitLength(length)

    @classmethod
    def handleLengthProperty(cls, length, attrs):
        context = cls.currentOperandContext()

        if isinstance(context, PropertyListContext):
            value = context.obj
            refTarget = context.refTarget
        else:
            raise IDLError("Unhandled context for length property : {}".format(context))

        if isinstance(value, Constructor):
            cls.handleExplicitLength("function", length)
            return

        propName = "length"
        propValue = NumberValue(length, refTarget)
        newProp = Property(value, propName, propValue, refTarget)
        newProp.attrs = attrs
        value.setProperty(propName, newProp)

    @classmethod
    def handleExplicitName(cls, target, name):
        if target != "function" and target != "method":
            raise IDLError("Unhandled target {}".format(target))

        context = cls.currentOperandContext()
        if not isinstance(context, PropertyContext):
            raise IDLError(
                'Explicit "name" must be specified only for function property : {}'.format(
                    target
                )
            )

        value = context.prop.getValue()
        if value is None:
            raise IDLError("Property value should exist")

        if not isinstance(value, Function):
            raise IDLError(
                'Explicit "name" must be specified only for function property : {}'.format(
                    target
                )
            )

        value.setExplicitName(name)

    @classmethod
    def handleNameProperty(cls, name):
        context = cls.currentOperandContext()

        if isinstance(context, PropertyListContext):
            value = context.obj
            refTarget = context.refTarget
        else:
            raise IDLError("Unhandled context for length property : {}".format(context))

        propName = "name"
        propValue = StringValue(name, refTarget)
        newProp = Property(value, propName, propValue, refTarget)
        value.setProperty(propName, newProp)

    @classmethod
    def parseValue(cls, prop, valueText):
        refTarget = prop.refTarget

        m = re.match(r"the (.+) prototype object$", valueText)
        if m:
            name = removeIntrinsicSign(m.group(1))

            value = PrototypeReferenceValue(name)
            logger.debug("Create reference for initial value : {}".format(value))
            return value

        m = re.match(r"a (_NativeError_) prototype object(?: \(\))$", valueText)
        if m:
            name = m.group(1)
            value = PrototypeReferenceValue(name)
            logger.debug("Create reference for initial value : {}".format(value))
            return value

        m = re.match(
            r"(?:the intrinsic object )?%([^%]+)%(?:, defined in.+)?$", valueText
        )
        if m:
            name = m.group(1)

            # (special case) Async Iterator Helpers.
            #if name == "AsyncIterator.prototype":
            #    name = "AsyncIteratorPrototype"

            value = ExpressionReferenceValue(name)
            logger.debug("Create reference for initial value : {}".format(value))
            return value

        m = re.match(
            r"the well-known symbol %(Symbol\.[A-Za-z0-9]+)%(?: \(\))?$", valueText
        )
        if m:
            value = m.group(1)
            return SymbolValue(value, refTarget)

        m = re.match(r"the String value \*\"(.+)\"\*", valueText)
        if m:
            value = m.group(1)
            return StringValue(value, refTarget)

        m = re.match(
            r"the String value consisting of the name of the constructor", valueText
        )
        if m:
            return ConstructorNameValue(refTarget)

        m = re.match(
            r"the Element Size value specified in for _TypedArray_$", valueText
        )
        if m:
            return ElementSizeValue(refTarget)

        m = re.match(r"\*\"(.+)\"\*$", valueText)
        if m:
            value = m.group(1)
            return StringValue(value, refTarget)

        m = re.match(r"the empty String$", valueText)
        if m:
            return StringValue("", refTarget)

        m = re.match(
            r"the Number value for the magnitude of the difference between 1 and the smallest value greater than 1 that is representable as a Number value",
            valueText,
        )
        if m:
            return SpecialNumberValue("EPSILON", refTarget)

        m = re.match(r"the largest positive finite value of the Number type", valueText)
        if m:
            return SpecialNumberValue("MAX_VALUE", refTarget)

        m = re.match(r"the smallest positive value of the Number type", valueText)
        if m:
            return SpecialNumberValue("MIN_VALUE", refTarget)

        m = re.match(r"\*NaN\*", valueText)
        if m:
            return NumberValue("NaN", refTarget)

        m = re.match(r"\*-∞\*𝔽", valueText)
        if m:
            return NumberValue("-Infinity", refTarget)

        m = re.match(r"\*\+∞\*𝔽", valueText)
        if m:
            return NumberValue("Infinity", refTarget)

        m = re.match(r"\*(-?[0-9]+)\*𝔽", valueText)
        if m:
            value = m.group(1)
            return NumberValue(value, refTarget)

        m = re.match(r"\*undefined\*", valueText)
        if m:
            return UndefinedValue(refTarget)

        m = re.match(r"the value \*null\*", valueText)
        if m:
            return NullValue(refTarget)

        if valueText == "_realm_.[[GlobalEnv]].[[GlobalThisValue]]":
            return GlobalThisValue(refTarget)

        m = re.match(r"the constructor itself", valueText)
        if m:
            context = cls.currentOperandContext()
            if not isinstance(context, PropertyContext):
                raise IDLError("Initial value in wrong context : {}".format(context))
            if context.owner.name == "_NativeError_ Prototype":
                return NamedObjects.get("_NativeError_")
            if context.owner.name == "_TypedArray_ Prototype":
                return NamedObjects.get("_TypedArray_")
            raise IDLError(
                "Unsupported context for 'constructor itself' : {}".format(context)
            )

        m = re.match(
            r"the corresponding (_TypedArray_) prototype intrinsic object", valueText
        )
        if m:
            name = m.group(1)
            value = PrototypeReferenceValue("_TypedArray_")
            logger.debug("Create reference for initial value : {}".format(value))
            return value

        raise IDLError("Unhandled initial value: {}".format(valueText))

    @classmethod
    def handleInitialValue(cls, targetName, valueText):
        context = cls.currentOperandContext()

        if not isinstance(context, PropertyContext):
            raise IDLError("Initial value in wrong context : {}".format(context))

        cls.validateInitialValueTarget(context.owner, context.prop, removeIntrinsicSign(targetName))

        cls.handleInitialValueFor(context.prop, valueText)

    @classmethod
    def handleInitialPropertyValue(cls, propName, valueText):
        context = cls.currentOperandContext()
        if not isinstance(context, PropertyContext):
            raise IDLError("Initial value in wrong context : {}".format(context))

        if context.prop.name != propName:
            raise IDLError(
                "Target of initial value. Expected {}, got {}".format(
                    context.prop.name, propName
                )
            )

        cls.handleInitialValueFor(context.prop, valueText)

    @classmethod
    def handleInitialValueFor(cls, prop, valueText):
        initialValue = cls.parseValue(prop, valueText)

        logger.debug("Set initial value for {} property".format(prop.name))
        prop.setValue(initialValue)

    @classmethod
    def handleNumberValue(cls, valueText):
        context = cls.currentOperandContext()

        if not isinstance(context, PropertyContext):
            raise IDLError("Unexpected context for number value {}".format(context))

        prop = context.prop
        refTarget = prop.refTarget

        if valueText == "e":
            value = SpecialNumberValue("E", refTarget)
        elif valueText == "the natural logarithm of 10":
            value = SpecialNumberValue("LN10", refTarget)
        elif valueText == "the natural logarithm of 2":
            value = SpecialNumberValue("LN2", refTarget)
        elif valueText == "the base-10 logarithm of e":
            value = SpecialNumberValue("LOG10E", refTarget)
        elif valueText == "the base-2 logarithm of e":
            value = SpecialNumberValue("LOG2E", refTarget)
        elif valueText == "π":
            value = SpecialNumberValue("PI", refTarget)
        elif valueText == "the square root of ½":
            value = SpecialNumberValue("SQRT1_2", refTarget)
        elif valueText == "the square root of 2":
            value = SpecialNumberValue("SQRT2", refTarget)
        else:
            raise IDLError("Unhandled initial value: {}".format(valueText))

        logger.debug("Set initial value for {} property".format(prop.name))
        prop.setValue(value)

    @classmethod
    def maybeHandleParagraph(cls, node):
        text = re.sub("[ \r\n\t]+", " ", str(node.text_content()).strip())

        with cls.parsingText(text):
            cls.maybeHandleParagraphText(text, node)

    @classmethod
    def handleURIReference(cls, href):
        context = cls.currentOperandContext()
        if not isinstance(context, PropertyContext):
            raise IDLError(
                '"See" reference found in unexpected context : {}'.format(context)
            )

        if context.prop.value is not None:
            raise IDLError(
                '"See" reference conflicts with other property : {}'.format(
                    context.prop.value
                )
            )

        ref = href[1:]

        refTarget = RefTarget(cls.specURL, ref, "")
        context.prop.setValue(URIReferenceValue(refTarget))

    @classmethod
    def maybeHandleParagraphText(cls, text, node):
        context = cls.maybeCurrentOperandContext()
        if context is None:
            return

        # Attributes can appear in the same paragraph as others.

        handledAttributes = False
        m = re.search(
            r"(?:This property|It|The \*\"length\"\* property) (?:initially )?(?:has|shall have) the attributes (\{.+\})",
            text,
        )
        if m:
            attrs = m.group(1)
            cls.handleAttributes(attrs)
            handledAttributes = True

        m = re.search(r"is an accessor property with attributes \{(.+)\}", text)
        if m:
            attrs = m.group(1)
            cls.handleAttributes(attrs)
            handledAttributes = True

        m = re.match(
            r"Unless otherwise specified, the \*\"(length|name)\"\* property of a built-in function object has the attributes",
            text,
        )
        if m:
            # IDL doesn't use "length" property's attributes.
            return

        m = re.match(
            r"Every other data property described in clauses through and in Annex has the attributes \{(.+)\} unless otherwise specified\.",
            text,
        )
        if m:
            attrs = Attributes.fromText(m.group(1))
            assert DEFAULT_WRITABLE == attrs.writable
            assert DEFAULT_ENUMERABLE == attrs.enumerable
            assert DEFAULT_CONFIGURABLE == attrs.configurable
            return

        m = re.match(
            r"Every accessor property described in clauses through and in Annex has the attributes \{(.+)\} unless otherwise specified\.",
            text,
        )
        if m:
            attrs = Attributes.fromText(m.group(1))
            assert DEFAULT_ENUMERABLE == attrs.enumerable
            assert DEFAULT_CONFIGURABLE == attrs.configurable
            return

        if not handledAttributes:
            if "attributes {" in text:
                raise IDLError("Possible attributes in {}".format(text))

        # (special case) Intl
        # This is in the same paragraph as intrinsic name.
        m = re.search(
            r"and the initial value of the \*\"([A-Za-z_][A-Za-z0-9_]*)\"\* property of the global object.",
            text,
        )
        if m:
            name = m.group(1)

            cls.handleGlobalProperty(name)

        # All others must be handled after attributes.

        if isinstance(context, InstancePropertyContext):
            return

        m = re.match(
            r"The value of the \[\[Prototype\]\] internal slot of the Intl object is the intrinsic object %Object.prototype%",
            text,
        )
        if m:
            # This is not an initial value for actual property.
            return

        # (special case) Temporal
        m = re.match(
            r"The value of the \[\[Prototype\]\] internal slot of the Temporal\..+ constructor is the intrinsic object %Function.prototype%",
            text,
        )
        if m:
            # This is not an initial value for actual property.
            return

        m = re.match(
            r"The (?:value of the )?\*\"length\"\* property of this (.+?) is \*\+?([0-9]+)\*𝔽",
            text,
        )
        if m:
            target, length = m.groups()

            cls.handleExplicitLength(target, length)
            return

        m = re.match(
            r"The (?:(?:initial )?value of the )?\*\"name\"\* property of this (.+?) is \*\"([^\"]+)\"\*",
            text,
        )
        if m:
            target, name = m.groups()

            cls.handleExplicitName(target, name)
            return

        m = re.match(
            r"The ((?:([A-Za-z_%][A-Za-z0-9_%]*(?:\.[A-Za-z_%][A-Za-z0-9_%]*)*)\.)?([A-Za-z_%][A-Za-z0-9_%]*)) (?:constructor|object) is (?:the )?%(.+)%(?: intrinsic object)?",
            text,
        )
        if m:
            targetName, parentExpr, name, expr = m.groups()

            cls.handleIntrinsicExpr(targetName, expr)
            return

        m = re.match(r"It is the %(.+)% intrinsic", text)
        if m:
            expr = m.group(1)

            cls.handleIntrinsicExpr(None, expr)
            return

        m = re.match(r"This function is the %(.+)% intrinsic", text)
        if m:
            expr = m.group(1)

            cls.handleIntrinsicExpr(None, expr)
            return

        m = re.match(
            r"The initial value of the (?:\*\"([^\"]+)\"\*|%(Symbol\.[A-Za-z0-9_]+)%) (?:data )?property (?:of the global object in a Realm Record _realm_ |of the prototype for a given _NativeError_ constructor |of the prototype for a given _TypedArray_ constructor )?is (.+)\.",
            text,
        )
        if m:
            targetName, symName, valueText = m.groups()

            if not targetName:
                targetName = symName

            cls.handleInitialPropertyValue(targetName, valueText)
            return

        if (
            text
            == "The initial value of the %Symbol.unscopables% data property is an object created by the following steps:"
        ):
            # NOTE: Handled by emu-alg.
            return

        m = re.match(
            r"The (?:initial )?value of (?:a )?(%[A-Za-z0-9_]+%|_[A-Za-z0-9_]+_)?`([^`]+)` is (.+)\.",
            text,
        )
        if m:
            maybeParent, targetName, valueText = m.groups()

            if maybeParent:
                targetName = maybeParent + targetName

            cls.handleInitialValue(targetName, valueText)
            return

        m = re.match(r"The initial value of NativeError\.prototype is (.+?)\.", text)
        if m:
            # NOTE: NativeError here is already enclosed with <var>.
            targetName = "_NativeError_.prototype"
            valueText = m.group(1)
            cls.handleInitialValue(targetName, valueText)
            return

        m = re.match(
            r"The initial value of \*?([A-Za-z0-9_\.\[\]@]+)\*? is (.+)\.$", text
        )
        if m:
            targetName, valueText = m.groups()

            valueText = valueText

            cls.handleInitialValue(targetName, valueText)
            return

        m = re.match(r"The value of the \[\[(Get|Set)\]\] attribute is", text)
        if m:
            return

        if (
            text
            == "The initial value of a built-in function object's [[Prototype]] internal slot is %Function.prototype%, unless otherwise specified."
        ):
            return

        m = re.match(r"The Number value for (.+?),", text)
        if m:
            valueText = m.group(1)

            cls.handleNumberValue(valueText)
            return

        m = re.match(r"See \.", text)
        if m:
            href = node[0].get("href")

            cls.handleURIReference(href)
            return

        m = re.match(
            r"The value of the \*\"name\"\* property is explicitly specified for each built-in functions whose property key is a Symbol value",
            text,
        )
        if m:
            return

        m = re.match(r"The (?:initial )?value of (.+?) is (.+)", text)
        if m:
            raise IDLError("Unhandled possible initial value: {}".format(text))

    @classmethod
    def handleTypedArraysTable(cls, node):
        table = node[0]
        if table.tag != "table":
            raise IDLError(
                "TypedArray table must be table element, got {}".format(table.tag)
            )

        context = cls.currentOperandContext()
        if not isinstance(context, TypedArrayContext):
            raise IDLError(
                "Unexpected context for TypedArray table : {}".format(context)
            )

        for tr in table:
            tds = tr.xpath("./td")
            if len(tds) == 0:
                continue

            if len(tds) != 5:
                raise IDLError(
                    "Unexpected number of cells in TypedArray table row : {}".format(
                        len(tds)
                    )
                )

            text = tds[0].text_content().strip()
            (name, intrinsicExpr) = map(lambda x: x.strip(), text.split("\n"))
            elementSize = int(tds[2].text_content())

            refTarget = RefTarget(
                context.refTarget.specURL, context.refTarget.ref, name
            )

            value = TemplateInstantiation("_TypedArray_", name, refTarget)
            value.setTemplateParams({"ElementSize": elementSize})

            NamedObjects.addWith(value, removeIntrinsicSign(intrinsicExpr))

            logger.debug(
                "Create template instantiation for _TypedArray_ as {}".format(name)
            )

    @classmethod
    def maybeHandleTable(cls, node):
        caption = node.get("caption")
        if caption is None:
            # (special case) Intl / Temporal
            captionNode = node[0]
            if captionNode.tag != "emu-caption":
                raise IDLError("Table caption not found")

            caption = str(captionNode.text_content())

        if caption == "The TypedArray Constructors":
            cls.handleTypedArraysTable(node)
            return

        if caption == "Well-Known Intrinsic Objects":
            return

    @classmethod
    def parsingText(cls, text):
        context = ParsingTextContext(text)
        return ContextWith(context, cls.contextStack)

    @classmethod
    def walk(cls, node):
        oldPath = None
        if node.tag == "imported-node":
            oldPath = cls.path
            cls.path = node.get("path")

        cls.currentNode = node

        if node.tag in cls.unrelatedTags:
            return
        nodeType = node.get("type")
        if nodeType in cls.unrelatedTypes:
            ignore = True

            if nodeType == "internal method":
                context = cls.maybeCurrentOperandContext()
                if isinstance(context, ProxyHandlerContext):
                    ignore = False

            if ignore:
                return

        maybeRefTargetContext = None
        maybeContext = None

        if node.tag == "emu-table":
            cls.maybeHandleTable(node)
            return

        if node.tag == "emu-clause" or node.tag == "emu-annex":
            childNodes = list(node)

            header = None
            headerNode = None

            if childNodes[0].tag != "h1":
                raise IDLError("Header not found")

            cls.assertSimpleText(childNodes[0])

            headerNode = childNodes[0]
            header = str(headerNode.text_content())

            # (special case) ECMA402
            if header == "Internal slots":
                return

            if re.match(r"Abstract Operations($| for )", header):
                return
            if re.match(r"(?:.+) Abstract Operations$", header):
                return
            if re.match(r"(?:.+) Interfaces?$", header):
                return
            if re.match(r"(?:.+) Element Functions$", header):
                return
            if re.match(r"(?:.+) Exotic Objects?$", header):
                return
            if re.match(r"\s*(?:Static|Runtime) Semantics: ", header):
                return

            # (special case) Record & Tuple
            if header.startswith("FlattenIntoTuple ("):
                return
            if header.startswith("Purely editorial changes"):
                return
            if header == "Properties of Record Objects":
                return

            refTarget = RefTarget(cls.specURL, node.get("id"), header)
            maybeRefTargetContext = RefTargetContext(refTarget)
            cls.contextStack.append(maybeRefTargetContext)

            cls.currentNode = headerNode
            with cls.parsingText(header):
                maybeContext = cls.handleHeader(node, header)

            cls.currentNode = node
        elif node.tag == "p":
            cls.assertSimpleText(node)

            cls.maybeHandleParagraph(node)
        elif node.tag == "li":
            for n in node:
                if n.tag not in cls.listItemContentTags:
                    raise IDLError("Unsupported element in li : {}".format(n.tag))

            cls.maybeHandleListItem(node)
        elif node.tag == "emu-alg":
            cls.maybeHandleAlgorithm(node)

        if node.tag in cls.inlineTags:
            cls.assertSimpleText(node)

        if maybeContext:
            cls.contextStack.append(maybeContext)
            logger.debug("Enter {}".format(str(maybeContext)))

        for n in node:
            cls.walk(n)

        cls.currentNode = node

        if maybeContext:
            logger.debug("Leave {}".format(str(maybeContext)))
            cls.contextStack.pop()

        if maybeRefTargetContext:
            cls.contextStack.pop()

        if oldPath:
            cls.path = oldPath


def resolveTypedArrayReferences():
    logger.debug("Resolve TypedArray references")

    globalValue = evaluateExpression("Global")

    for propName, prop in globalValue.props.items():
        if not isinstance(prop.value, URIReferenceValue):
            continue

        value = prop.value.deref()
        if value.name == "_TypedArray_":
            value = NamedObjects.get(propName)
            prop.setValue(value)


class SpecParser:
    @classmethod
    def parse(cls, path):
        with open(path, "r") as f:
            content = f.read()
        dom = lxml.html.fromstring(content)

        for importElem in dom.xpath("//emu-import"):
            subPath = path.parent / importElem.get("href")
            sub = cls.parse(subPath)

            node = lxml.html.Element("imported-node", {"path": str(subPath)})
            node.append(sub)

            importElem.getparent().replace(importElem, node)

        return dom

    @classmethod
    def parseAll(cls, args):
        doms = []
        for path in args:
            if path == "-v":
                logging.basicConfig(level=logger.debug)
                continue

            dirname = path.split("/")[1]
            specURL = "https://tc39.es/" + dirname + "/"

            dom = cls.parse(pathlib.Path(path))
            doms.append((dom, path, specURL))

        for dom, path, specURL in doms:
            logger.debug("Walk {}".format(specURL))

            TreeWalker.process(dom, path, specURL)

        resolveTypedArrayReferences()
        ReferenceValue.derefAll()
        TemplateInstantiation.instantiateAll()


def isGlobalProperty(value):
    globalValue = evaluateExpression("Global")
    return globalValue.hasProperty(value.name)


class IDLPrinter:
    def __init__(self, out):
        self.out = out

    def collectMembers(
        self,
        topLevelRefTarget,
        value,
        accessorMembers,
        additionalAccessorMembers,
        methodMembers,
        additionalMethodMembers,
        dataMembers,
        additionalDataMembers,
        ctorValue,
        protoValue,
    ):
        for prop in value.props.values():
            if prop.isDataProperty():
                propValue = prop.getValue()
                if propValue is None:
                    raise IDLError(
                        "Property value must have been resolved : {} in {}".format(
                            prop.name, value.name
                        )
                    )

                if propValue == ctorValue:
                    continue
                if propValue == protoValue:
                    continue

                if isinstance(propValue, TemplateInstantiation):
                    newProp = prop.cloneWithValue(propValue.instantiate())
                    newProp.isReference = prop.isReference
                    prop = newProp
                    propValue = prop.value

                if prop.isReference and isinstance(propValue, Object):
                    if isinstance(propValue, Constructor) or not isinstance(
                        propValue, Function
                    ):
                        if propValue.qualifiedName is None:
                            relativeName = propValue.name
                        else:
                            relativeName = propValue.qualifiedName

                        propValue = ObjectRefValue(relativeName, propValue.refTarget)
                        prop = prop.cloneWithValue(propValue)

            if topLevelRefTarget.specURL == prop.getSpecURL():
                if prop.isDataProperty():
                    if isinstance(prop.getValue(), Function):
                        methodMembers.append(prop)
                    else:
                        dataMembers.append(prop)
                else:
                    accessorMembers.append(prop)
            else:
                if prop.isDataProperty():
                    if isinstance(prop.getValue(), Function):
                        additionalMethodMembers.append(prop)
                    else:
                        additionalDataMembers.append(prop)
                else:
                    additionalAccessorMembers.append(prop)

    def printInterfaceMembers(self, value, interfaceKind, interfaceName):
        interfaceQualifiedName = interfaceName
        if value.qualifiedName:
            interfaceQualifiedName = value.qualifiedName

        unscopableNames = []
        protoValue = None
        if isinstance(value, Constructor) and value.hasPrototype():
            prop = value.getProperty("prototype")
            protoValue = prop.getValue()

            if isinstance(protoValue, NullValue):
                protoValue = None
            elif protoValue.hasProperty("Symbol.unscopables"):
                prop = protoValue.getProperty("Symbol.unscopables")
                unscopableNames = prop.getValue().names

        instanceValue = None
        if isinstance(value, Constructor) and value.hasPrototype():
            proto = value.getPrototype()
            if proto.hasInstance():
                instanceValue = proto.getInstance()

        isGlobal = False
        if value.name == "Global":
            isGlobal = True

        staticAccessorMembers = []
        staticMethodMembers = []
        staticDataMembers = []

        protoAccessorMembers = []
        protoMethodMembers = []
        protoDataMembers = []

        instanceAccessorMembers = []
        instanceMethodMembers = []
        instanceDataMembers = []

        additionalStaticAccessorMembers = []
        additionalStaticMethodMembers = []
        additionalStaticDataMembers = []

        additionalProtoAccessorMembers = []
        additionalProtoMethodMembers = []
        additionalProtoDataMembers = []

        additionalInstanceAccessorMembers = []
        additionalInstanceMethodMembers = []
        additionalInstanceDataMembers = []

        self.collectMembers(
            value.refTarget,
            value,
            staticAccessorMembers,
            additionalStaticAccessorMembers,
            staticMethodMembers,
            additionalStaticMethodMembers,
            staticDataMembers,
            additionalStaticDataMembers,
            value,
            protoValue,
        )
        if protoValue:
            self.collectMembers(
                value.refTarget,
                protoValue,
                protoAccessorMembers,
                additionalProtoAccessorMembers,
                protoMethodMembers,
                additionalProtoMethodMembers,
                protoDataMembers,
                additionalProtoDataMembers,
                value,
                protoValue,
            )
        if instanceValue:
            self.collectMembers(
                value.refTarget,
                instanceValue,
                instanceAccessorMembers,
                additionalInstanceAccessorMembers,
                instanceMethodMembers,
                additionalInstanceMethodMembers,
                instanceDataMembers,
                additionalInstanceDataMembers,
                None,
                None,
            )

        hadMemberAfterEmptyLine = False

        lastSpecURL = value.refTarget.specURL

        constNames = []
        constMembers = []

        for prop in staticDataMembers:
            propValue = prop.getValue()

            for protoProp in protoDataMembers:
                if protoProp.name != prop.name:
                    continue
                if protoProp.attrs.toTuple() != prop.attrs.toTuple():
                    continue
                if not protoProp.getValue().equals(prop.getValue()):
                    continue

                prop.isConst = True

                constNames.append(prop.name)
                constMembers.append(prop)

        staticDataMembers = filter(lambda prop: prop.name not in constNames, staticDataMembers)
        protoDataMembers = filter(lambda prop: prop.name not in constNames, protoDataMembers)

        for owner, members in [
            (value, constMembers),

            (value, staticDataMembers),
            (value, staticAccessorMembers),
            (value, staticMethodMembers),

            (protoValue, protoAccessorMembers),
            (protoValue, protoMethodMembers),
            (protoValue, protoDataMembers),

            (instanceValue, instanceAccessorMembers),
            (instanceValue, instanceMethodMembers),
            (instanceValue, instanceDataMembers),

            (value, additionalStaticDataMembers),
            (value, additionalStaticAccessorMembers),
            (value, additionalStaticMethodMembers),

            (protoValue, additionalProtoAccessorMembers),
            (protoValue, additionalProtoMethodMembers),
            (protoValue, additionalProtoDataMembers),

            (instanceValue, additionalInstanceAccessorMembers),
            (instanceValue, additionalInstanceMethodMembers),
            (instanceValue, additionalInstanceDataMembers),
        ]:
            if isinstance(value, ExoticObject):
                isStatic = False
                isPrototype = False
                isInstance = True
            if isinstance(value, Dictionary):
                isStatic = False
                isPrototype = False
                isInstance = False
            else:
                isStatic = owner == value
                isPrototype = owner == protoValue
                isInstance = owner == instanceValue

            isFirstInSection = True
            for prop in members:
                if isinstance(owner, Dictionary):
                    prefix = ""
                    member = prop.getValue()
                    if prop.optional:
                        prefix = "optional "
                    print("  {}{} {};".format(prefix, member.typeName, prop.name), file=self.out)
                    continue

                if prop.isDataProperty() and isinstance(prop.getValue(), ObjectRefValue):
                     if isGlobal:
                         continue
                     if owner.qualifiedName:
                         name = owner.qualifiedName + "." + prop.name
                     else:
                         name = owner.name + "." + prop.name
                     if name == evaluateExpression(prop.getValue().value).qualifiedName:
                         continue

                if prop.isDataProperty() and prop.name == "Symbol.unscopables":
                    # Defined internally.
                    assert not prop.attrs.writable
                    assert not prop.attrs.enumerable
                    assert prop.attrs.configurable
                    continue

                if prop.name == "Symbol.toStringTag" and prop.isDataProperty() and not prop.attrs.writable and not prop.attrs.enumerable and prop.attrs.configurable:
                    if isinstance(prop.getValue(), StringValue) and prop.getValue().value == interfaceQualifiedName:
                        if interfaceKind in ["namespace", "prototype"] and owner == value:
                            continue
                        if interfaceKind in ["interface"] and owner == protoValue:
                            continue

                extendedAttributes = []
                specifiers = []

                if isInstance:
                    if config.useInstanceSyntax:
                        specifiers.append("instance")
                    else:
                        extendedAttributes.append("Instance")

                extendedAttributes += prop.extendedAttributes()

                if isinstance(owner, Prototype) and config.usePrototypeInterface:
                    pass
                else:
                    if isStatic and not isGlobal and not prop.isConst and interfaceKind != "namespace":
                        specifiers.append("static")

                if prop.isDataProperty():
                    propValue = prop.getValue()

                    if len(propValue.referrers) > 0:
                        names = []
                        for reference in propValue.referrers:
                            relativeName = toRelativeName(reference, owner)
                            names.append(relativeName)

                        extendedAttributes.append('Alias="{}"'.format(",".join(names)))

                # NOTE: Avoid conflict with static attribute.
                if not config.useRawName and isPrototype and prop.name == "BYTES_PER_ELEMENT":
                    extendedAttributes = [
                        'Name="{}"'.format(prop.name)
                    ] + extendedAttributes
                    prop = prop.cloneWithValue(prop.getValue())
                    prop.safeName = prop.name + "_"

                if isPrototype and prop.name in unscopableNames:
                    extendedAttributes.append("Unscopable")

                needsEmptyLine = False

                if isFirstInSection:
                    if hadMemberAfterEmptyLine:
                        needsEmptyLine = True
                        hadMemberAfterEmptyLine = False
                    isFirstInSection = False

                currentSpecURL = prop.getSpecURL()
                if currentSpecURL != lastSpecURL:
                    needsEmptyLine = True

                if currentSpecURL != lastSpecURL:
                    print("}", file=self.out)
                    print("", file=self.out)
                    print(
                        "// {}".format(SpecTitles.get(currentSpecURL)), file=self.out
                    )
                    if currentSpecURL.startswith("http"):
                        print("// {}".format(currentSpecURL), file=self.out)
                    print("partial {} {} {{".format(interfaceKind, interfaceName), file=self.out)
                    lastSpecURL = currentSpecURL
                elif needsEmptyLine:
                    print("", file=self.out)

                if prop.isReference:
                    if prop.value.parent == owner:
                        relativeName = prop.value.name
                    elif prop.value.qualifiedName is None:
                        relativeName = prop.value.name
                    else:
                        relativeName = prop.value.qualifiedName

                    print(
                        '  // "{}" property is aliased from "{}".'.format(
                            toPropName(prop.name), toPropName(relativeName)
                        ),
                        file=self.out,
                    )
                else:
                    if prop.mod is not None and prop.mod.hasBefore():
                        prop.mod.forEachBefore(
                            extendedAttributes,
                            lambda macro: self.printMacro(macro),
                            lambda attrs: self.printExtendedAttributes("  ", attrs),
                        )
                    else:
                        self.printExtendedAttributes("  ", extendedAttributes)

                    print(
                        "  {};".format(" ".join(specifiers + [str(prop)])),
                        file=self.out,
                    )
                hadMemberAfterEmptyLine = True

                if prop.mod is not None and prop.mod.hasAfter():
                    prop.mod.forEachAfter(lambda macro: self.printMacro(macro))

    def printExtendedAttributes(self, indent, extendedAttributes):
        if len(extendedAttributes) > 0:
            print(
                "{}[{}]".format(indent, ", ".join(extendedAttributes)),
                file=self.out,
            )

    def printMacro(self, macro):
        print(macro, file=self.out)

    def getInheritance(self, value):
        if config.usePrototypeInterface and isinstance(value, Prototype):
            if value.prototypeSlot is None:
                return ""

            return str(value.prototypeSlot)

        if not isinstance(value, Constructor):
            return ""

        if not value.hasPrototype():
            return ""

        prop = value.getProperty("prototype")
        proto = prop.getValue()
        if isinstance(proto, NullValue):
            return ""

        if not proto.prototypeSlot:
            return ""

        if proto.prototypeSlot == "null":
            return "null"

        parentProto = evaluateExpression(proto.prototypeSlot)

        maybeParentCtor = parentProto.parent
        if not maybeParentCtor:
            return ""

        if not isinstance(maybeParentCtor, Constructor):
            return ""

        name = maybeParentCtor.name
        if name == "Object":
            return ""

        return name

    def printInterface(self, value):
        if isinstance(value, TemplateInstantiation):
            value = value.instantiate()

        logger.debug("Convert {} into interface".format(value.name))

        if value.refTarget:
            if isinstance(value, Constructor):
                refTarget = value.objectsRefTarget
            else:
                refTarget = value.refTarget

            if refTarget.header:
                print("// {}".format(refTarget.header), file=self.out)
                print("// {}".format(refTarget.toURI()), file=self.out)

        kind = "interface"
        if isinstance(value, SingletonObject) and value.name != "Global":
            kind = "namespace"
        elif isinstance(value, Dictionary):
            kind = "dictionary"
        elif isinstance(value, Prototype):
            if config.usePrototypeInterface:
                kind = "prototype"
            else:
                kind = "namespace"

        inheritance = self.getInheritance(value)

        name = value.name

        if " " in name:
            raise IDLError("No space allowed in interface name : {}".format(name))

        extendedAttributes = []

        if isGlobalProperty(value):
            extendedAttributes.append("Exposed=*")
        elif value.parent:
            extendedAttributes.append("LegacyNamespace={}".format(value.parent.name))

        if name == "Global":
            extendedAttributes.append("Global=Global")

        safeName = name
        if value.hasSafeName():
            extendedAttributes.append('Name="{}"'.format(name))
            safeName = value.safeName

        if value.prototypeSlot:
            prototypeSlot = value.prototypeSlot
            if prototypeSlot == inheritance:
                pass
            elif isinstance(value, Function) and prototypeSlot == "Function.prototype":
                pass
            elif isinstance(value, Object) and prototypeSlot == "Object.prototype":
                pass
            else:
                # (special case) Async Iterator Helpers.
                #if prototypeSlot == "AsyncIteratorPrototype":
                #    prototypeSlot = "AsyncIterator.prototype"

                if not config.usePrototypeInterface:
                    extendedAttributes.append('PrototypeSlot="{}"'.format(prototypeSlot))

        if inheritance == "null" and not config.useInheritanceExpression:
            inheritance = None
            extendedAttributes.append("PrototypeSlot=null")


        if kind in ["interface", "prototype"]:
            extendedAttributes.append("NoBrandCheck")

        if kind in ["interface"]:
            extendedAttributes.append("NoNewTargetCheck")
            extendedAttributes.append("NoObjectCreation")
            extendedAttributes.append("NoUnforgeablesSlot")

        if isinstance(value, Constructor) and value.hasPrototype():
            proto = value.getPrototype()
            if proto.isCustom:
                extendedAttributes.append("CustomPrototype")

        if value.mod is not None and value.mod.hasBefore():
            value.mod.forEachBefore(
                extendedAttributes,
                lambda macro: self.printMacro(macro),
                lambda attrs: self.printExtendedAttributes("", attrs),
            )
        else:
            self.printExtendedAttributes("", extendedAttributes)

        inheritanceExpr = ""
        if inheritance:
            inheritanceExpr = " : {}".format(inheritance)

        print("{} {}{} {{".format(kind, safeName, inheritanceExpr), file=self.out)
        if isinstance(value, Constructor):
            specifiers = []
            extendedAttributes = []

            if value.hasPrototype():
                prototype = value.getPrototype()
                if prototype.hasProperty("constructor"):
                    defaultWritable = True
                    defaultEnumerable = False
                    defaultConfigurable = True

                    attrs = prototype.getProperty("constructor").attrs

                    populateDescriptor("property", attrs,
                                       defaultWritable,
                                       defaultEnumerable,
                                       defaultConfigurable,
                                       specifiers, extendedAttributes)

            if value.explicitLength:
                extendedAttributes.append('Length="{}"'.format(value.explicitLength))

            if value.constructorMod is not None and value.constructorMod.hasBefore():
                value.constructorMod.forEachBefore(
                    extendedAttributes,
                    lambda macro: self.printMacro(macro),
                    lambda attrs: self.printExtendedAttributes("  ", attrs),
                )
            else:
                self.printExtendedAttributes("  ", extendedAttributes)

            prefix = ""
            if len(specifiers) > 0:
                prefix = " ".join(specifiers) + " "

            print("  {}constructor{};".format(prefix, str(value.params)), file=self.out)
            print("", file=self.out)

            if value.constructorMod is not None and value.constructorMod.hasAfter():
                value.constructorMod.forEachAfter(lambda macro: self.printMacro(macro))

        self.printInterfaceMembers(value, kind, safeName)

        print("};", file=self.out)

        if value.mod is not None and value.mod.hasAfter():
            value.mod.forEachAfter(lambda macro: self.printMacro(macro))

    def printCallback(self, value):
        refTarget = value.refTarget

        print("", file=self.out)
        print("// {}".format(refTarget.toURI()), file=self.out)
        print("callback {} = any {};".format(value.typeName, str(value.params)),
              file=self.out)

    def printInterfaces(self):
        print(fileHeader, file=self.out)

        lastSpecURL = None
        isFirst = True

        for name, item in Index.values.items():
            if re.match(r"^_.+_$", item.name):
                continue

            if isinstance(item, Callback):
                self.printCallback(item)
                continue

            if isinstance(item, Function) and not isinstance(item, Constructor):
                continue

            if not isFirst:
                print("", file=self.out)
            isFirst = False

            currentSpecURL = item.refTarget.specURL
            if currentSpecURL != lastSpecURL:
                print("// {}".format(SpecTitles.get(currentSpecURL)), file=self.out)
                if currentSpecURL.startswith("http"):
                    print("// {}".format(currentSpecURL), file=self.out)
                print("", file=self.out)
                lastSpecURL = currentSpecURL

            self.printInterface(item)

parser = argparse.ArgumentParser(prog="es2idl.py")
parser.add_argument("-v", "--verbose", action="store_true", default=False)
parser.add_argument("-o", dest="SPEC_WEBIDL_PATH")
parser.add_argument("-c", dest="CONFIG", choices=["new", "compat"])
parser.add_argument("SPEC_HTML_PATHS", nargs="*")

options = parser.parse_args()

if options.CONFIG == "new":
    config = NewSyntaxConfig
elif options.CONFIG == "compat":
    config = CompatibleConfig

if options.verbose:
    log_level = logging.DEBUG
else:
    log_level = logging.WARNING
logging.basicConfig(level=log_level)
logger = logging.getLogger('es2idl')

specPath = pathlib.Path(options.SPEC_WEBIDL_PATH)

SpecParser.parseAll(options.SPEC_HTML_PATHS)

with open(specPath, "w") as fh:
    IDLPrinter(fh).printInterfaces()
